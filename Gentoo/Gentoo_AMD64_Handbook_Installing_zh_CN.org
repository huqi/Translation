#+TITLE: Gentoo Linux amd64 手册: 安装Gentoo
#+SETUPFILE:readtheorg.setup
* 序言

** 欢迎

首先，欢迎来到Gentoo。您将进入选择和性能的世界。Gentoo处处都是选择。当安装Gentoo时，这点你会感受到好几次，用户可以选择编译多少软件，怎么安装，系统使用什么系统日志程序等，等等。

Gentoo是一个快速而先进的元发行版本，它有着简洁和灵活的设计理念。Gentoo是由自由软件编译而成，它不向用户隐藏任何东西。Gentoo使用Portage进行软件包管理，它用Python编写而成，用户可以轻松的查看和修改源代码。Gentoo软件包管理系统使用源代码（虽然也支持预编译软件包）进行管理，配置文件使用普通的文本文件。也就是说，处处都是开放的。

让用户明白怎么选择可以运行Gentoo是非常重要的。我们不会强迫用户做他们不喜欢的事情，如果你觉得我有的话，请[[https://bugs.gentoo.org/][告诉]]我们。

** 安装的结构

Gentoo的安装可以视为10个步骤，依照下面的步骤，可以达到相应的状态。

  1. 第1步后，用户处在一个准备安装Gentoo的环境中
  2. 第2步后，已经准备好用于安装Gentoo的网络环境
  3. 第3步后，硬盘初始化完毕，可以用于安装Gentoo
  4. 第4步后，系统环境就绪，用户准备chroot新的环境中
  5. 第5步后，所有Gentoo都要安装的核心软件包已经安装完毕
  6. 第6步后，Linux内核安装完毕
  7. 第7步后，用户已经配置好了大部分Gentoo配置文件
  8. 第8步后，已经安装好必要的软件
  9. 第9步后，已经安装并配置好bootloader
  10. 第10步后，Gentoo环境安装成功，已经可以开始使用了

当做出一个特定的选择时，手册会解释利与弊。虽然有一个默认的选择用于继续（在标题中用“默认：”标识），同时也会提供其它的可能（在标题中用“选择：”标识），不要认为默认是Gentoo推荐的设置，其实只是Gentoo认为大多数用户会选择它。

有一些并不是安装Gentoo所必须的可选的步骤，这些步骤用“选项：”标识。有一些选项依赖于之前的操作，不用担心，在做出选择时和可选步骤前，我们都会有相应的提示。

** 怎么选择

Gentoo可以用很多方式进行安装。可以通过下载Gentoo光盘安装，可以通过一个安装好的发行版进行安装，从一个不是Gentoo（例如Knoppix）的启动光盘进行安装，从网络安装，从急救光盘安装，等。

本文档包含了通过安装光盘安装，同时也包含了一些网络安装的方法。

#+BEGIN_QUOTE
*备注*

其它方式安装的帮助，包括非Gentoo安装光盘的安装方法，请查看[[https://wiki.gentoo.org/wiki/Installation_alternatives][其它安装指南]]
#+END_QUOTE

我们也提供了一个可能很有用的[[https://wiki.gentoo.org/wiki/Gentoo_installation_tips_and_tricks][Gentoo安装提示和技巧]]文档供你参考。

** 困难

如果你在安装的时候（或者在安装文档）发现了问题，请访问我们的[[https://bugs.gentoo.org/][bug追踪系统]]查看这个问题是否已经提交。如果还没有存在请提交一个bug报告给我们，我们会注意它。不要害怕负责你的bug的开发人员，他们不会吃人的。

可能你注意到，这个文档已经结构化了，包含了结构化文档的其它链接。这是因为Gentoo的手册使用了大量的源代码（也是为了减少文档的复杂度和提高使用效率）。我们会尽量保证不会让你困惑。

如果有一些不确定是用户问题（尽管用户已经仔细的阅读了手册）还是系统问题（尽管我们已经仔细的测试过这些文档），我们欢迎任何人人加入在irc.freenode.net上的#gentoo频道。当然，也欢迎加入其它的关于Gentoo的频道。

说到这，如果有其它关于Gentoo的问题，请看[[https://wiki.gentoo.org/wiki/Main_Page][Gentoo Wiki]]里的[[https://wiki.gentoo.org/wiki/FAQ][常见问题]]，[[https://forums.gentoo.org/][Gentoo论坛]]上也有[[https://forums.gentoo.org/viewforum.php?f%3D40][FAQs]]。

* 硬件需求

在开始前，我们列出了成功安装Gentoo amd64的硬件需求。

|           | Minimal CD                                                          | LiveDVD |
| CPU       | Any AMD64 CPU or [[http://en.wikipedia.org/wiki/EMT64#Intel_64][EM64T]] CPU (Core 2 Duo & Quad processors are EM64T) |         |
| Memory    | 256 MB                                                              | 512 MB  |
| Diskspace | 2.5 GB (excluding swap space)                                       |         |
| Swapspace | At least 256 MB                                                     |         |

[[https://www.gentoo.org/proj/en/base/amd64/][Gentoo AMD64 项目站点]]有更多关于Gentoo AMD64的信息。

* Gentoo安装CD

** 最小安装CD

Gentoo最小安装CD是一个包含自支持环境Gentoo系统。用户可以从CD中启动，在启动的过程中系统会自动加载合适的硬件驱动。这个CD由Gentoo开发者负责维护，供用户在有网络链接的情况下安装Gentoo。

最小安装CD的文件名为 /install-amd64-minimal-<release>.iso/ 。

** 临时LiveDVD

有时候，Gentoo Ten项目会精心制作一个用于安装Gentoo的特别DVD版本。进一步减少安装步骤，可能和最小安装CD有一点不一样。然而，LiveDVD（或者其它的可启动的Linux环境）可能通过在终端输入 =sudo su -= 或者 =sudo -i= 来获取root权限。

** 用什么stages

stage3是一个包含最小Gentoo环境的存档。适用本文档里的指令去安装Gentoo。以前，Gentoo手册说过可以使用3个包中的一个进行安装。虽然Gentoo依然支持stage1和stage2存档包进行安装，但正式的安装方法是用stage3进行安装。如果你对stage1和stage2安装感兴趣，请阅读Gentoo FAQ里的[[https://wiki.gentoo.org/wiki/FAQ#How_do_I_Install_Gentoo_Using_a_Stage1_or_Stage2_Tarball.3F][怎么用Stage1和Stage2安装Gentoo]]？

Gentoo安装CD不提供Stage3，用户可以去任何一个[[https://www.gentoo.org/downloads/mirrors/][正式Gentoo镜像]]，releases/amd64/autobuilds目录下载Stage3。

* 下载和烧录CD

** 下载媒体

Gentoo默认的安装媒体是最小安装CD，他是一个包含正确工具的可自启动的Gentoo Linux环境。有很多镜像可以下载这个CD。

在这些镜像中，你可以按如下路径找到最小安装CD：

  1. 找到releases/目录
  2. 选择正确的架构，例如amd64
  3. 选择autobuilds/目录
  4. 选择current-iso/目录

在这个位置，安装CD文件以.iso后缀。例如，请看下面这个列表：

#+BEGIN_SRC
CODE Example list of downloadable files at releases/amd64/autobuilds/current-iso/

[DIR] hardened/                                         05-Dec-2014 01:42 -
[   ] install-amd64-minimal-20141204.iso                04-Dec-2014 21:04 208M
[   ] install-amd64-minimal-20141204.iso.CONTENTS       04-Dec-2014 21:04 3.0K
[   ] install-amd64-minimal-20141204.iso.DIGESTS        04-Dec-2014 21:04 740
[TXT] install-amd64-minimal-20141204.iso.DIGESTS.asc    05-Dec-2014 01:42 1.6K
[   ] stage3-amd64-20141204.tar.bz2                     04-Dec-2014 21:04 198M
[   ] stage3-amd64-20141204.tar.bz2.CONTENTS            04-Dec-2014 21:04 4.6M
[   ] stage3-amd64-20141204.tar.bz2.DIGESTS             04-Dec-2014 21:04 720
[TXT] stage3-amd64-20141204.tar.bz2.DIGESTS.asc         05-Dec-2014 01:42 1.5K
#+END_SRC

在上面的例子中，install-amd64-minimal-20141204.iso文件就是最小安装CD。你也可以看到一些其它相关的文件：

  - A.CONTENTS文件是一个列出了安装CD中所有文件的文本文件。
  - A.DIGESTS文件包含了ISO文件的HASH值，这个文件可以用来验证下载的映像是否损坏。
  - A.DIGESTS.asc文件不只包含了ISO文件的HASH值（像.DIGESTS文件那样），还加密了那个文件的签名信息。这个文件不仅能验证文件是否损坏，还能验证是否是Gentoo团队释出的版本，以防止被它人篡改。

现在先忽略其它文件-接下来的安装中会用到他们时再说。先下载ISO映像，如果你想验证文件可靠性，也可以下载.DIGESTS.asc文件。我们不需要下载在接下来的安装中我们不用的.CONTENTS文件和.DIGESTS文件，因为我们已经有了加密了签名信息的.DIGESTS.asc文件。

** 验证下载文件

#+BGEIN_QUOTE
*备注*

在安装Gentoo Linux时，这是一个可选的步骤，但是还是推荐验证下载的文件以确保文件是由Gentoo团队提供的映像。
#+END_QUOTE

用合适的工具通过.DIGESTS和.DIGESTS.asc文件去验证ISO文件的正确性，验证的步骤如下：

  1. 对数字签名进行验证，以确保是由Gentoo团队提供的安装文件
  2. 如果数字签名验证正确，那么校验文件是否被损坏

*** Windows验证

在Windows系统中，不太容易在系统中找到合适的验证和数字签名工具。

验证数字签名的工具可以使用[[http://www.gpg4win.org/][GPG4Win]]，安装完成后，先导入Gentoo团队的公钥，密钥列表可以在[[https://www.gentoo.org/downloads/signatures/][签名页面]]找到。导入后用户可以用.DIGESTS.asc文件进行验证。

#+BEGIN_QUOTE
*重要*

这里是用.DIGESTS.asc文件验证而不是用.DIGESTS文件进行证。这也是为什么上面的说明只要求下载.DIESTS.asc文件。
#+END_QUOTE

校验文件可以使用[[http://www.sinf.gr/en/hashcalc.html][Hashcalc application]]，不过也有其它的一些工具可以使用，大多时候那些工具会显示文件的校验值，需要用户去核对.DIGESTS.asc文件里的校验值。

*** Linux验证

在Linux系统，通用的验证数字签名的方法是使用[[http://packages.gentoo.org/package/app-crypt/gnupg][app-crypt/gnupg软件。]]安装好软件后，可以用如下的命令通过.DIGESTS.asc文件来验证数字签名。

首先，下[[https://www.gentoo.org/downloads/signatures/][密钥页面]]上正确的密钥：

#+BEGIN_SRC
user $ gpg --recv-keys 0xBB572E0E2D182910

gpg: requesting key 0xBB572E0E2D182910 from hkp server pool.sks-keyservers.net
gpg: key 0xBB572E0E2D182910: "Gentoo Linux Release Engineering (Automated Weekly Release Key) <releng@gentoo.org>" 1 new signature
gpg: 3 marginal(s) needed, 1 complete(s) needed, classic trust model
gpg: depth: 0  valid:   3  signed:  20  trust: 0-, 0q, 0n, 0m, 0f, 3u
gpg: depth: 1  valid:  20  signed:  12  trust: 9-, 0q, 0n, 9m, 2f, 0u
gpg: next trustdb check due at 2018-09-15
gpg: Total number processed: 1
gpg:         new signatures: 1
#+END_SRC

然后，验证.DIGESTS.asc文件中的数字签名：

#+BEGIN_SRC
user $ gpg --verify install-amd64-minimal-20141204.iso.DIGESTS.asc

gpg: Signature made Fri 05 Dec 2014 02:42:44 AM CET
gpg:                using RSA key 0xBB572E0E2D182910
gpg: Good signature from "Gentoo Linux Release Engineering (Automated Weekly Release Key) <releng@gentoo.org>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 13EB BDBE DE7A 1277 5DFD  B1BA BB57 2E0E 2D18 2910
#+END_SRC

确认签名正确性，需要在[[https://www.gentoo.org/downloads/signatures/][Gentoo密钥页面]]上核对指纹。

验证完数字签名后，下一步校验ISO文件完整性。.DIGESTS.asc文件包含多种HASH算法的校验值，所以验证文件完整性的方法是确认在.DIGESTS.asc文件中某算法的值，例如SHA512校验：

#+BEGIN_SRC
user $ grep -A 1 -i sha512 install-amd64-minimal-20141204.iso.DIGESTS.asc

# SHA512 HASH
364d32c4f8420605f8a9fa3a0fc55864d5b0d1af11aa62b7a4d4699a427e5144b2d918225dfb7c5dec8d3f0fe2cddb7cc306da6f0cef4f01abec33eec74f3024  install-amd64-minimal-20141204.iso
--
# SHA512 HASH
0719a8954dc7432750de2e3076c8b843a2c79f5e60defe43fcca8c32ab26681dfb9898b102e211174a895ff4c8c41ddd9e9a00ad6434d36c68d74bd02f19b57f  install-amd64-minimal-20141204.iso.CONTENTS
#+END_SRC

上面的输出显示了两个SHA512校验值，一个是install-amd64-minimal-20141204.iso文件的校验值，一个是对应的.CONTENTS文件的校验值。我们只需要第一个值和我们计算的文件的校验值进行对比，我们可以用如下的命令去计算文件校验值：

#+BEGIN_SRC
user $ sha512sum install-amd64-minimal-20141204.iso

364d32c4f8420605f8a9fa3a0fc55864d5b0d1af11aa62b7a4d4699a427e5144b2d918225dfb7c5dec8d3f0fe2cddb7cc306da6f0cef4f01abec33eec74f3024  install-amd64-minimal-20141204.iso
#+END_SRC

如果两个校验值相同，那么我们可以确认文件没有损坏并继续安装。

** 刻录

当然，只是下载完ISO文件，Gentoo Linux安装程序不会自动启动，ISO文件需要刻录到CD中并启动，我们需要把ISO文件的内容记录到CD中，而不是ISO文件本身。下面所说的是一些简单方法—更详细的指令可以查看[[https://wiki.gentoo.org/wiki/FAQ#How_do_I_burn_an_ISO_file.3F][记录ISO文件常见问题]]。

*** Windows刻录

在Windows系统中有很多记录工具。

  - Easy Creator软件，选择文件，从CD映像刻录。修改文件类型为ISO映像，然后选择ISO文件并打开。点击开始后程序会把ISO映像正确的刻录到CD-R中。
  - Nero Burning ROM软件，取消自动弹出的向导，从文件菜单中选择刻录映像，选择映像并点击打开。然后点击刻录可以看到刻录过程。

*** Linux刻录

在Linux系统中，刻录ISO文件可以用[[http://packages.gentoo.org/package/app-cdr/cdrtools][app-cdr/cdrtools]]软件包中的 =cdrecord= 命令。

例如，刻录ISO文件到/dev/sr0设备（这是系统里的第一个CD设备，如果有需要请替换成正确的设备文件）：

#+BEGIN_SRC
user $ cdrecord dev=/dev/sr0 install--minimal-20141204.iso
#+END_SRC

用户可以选择[[http://packages.gentoo.org/package/app-cdr/k3b][app-cdr/k3b]]软件包中图形界面的刻录工具K3B，在K3B软件中，选择工具，刻录CD映像。然后根据接下来的提示进行操作。

* 启动CD

** 启动安装CD

如果已经刻录了CD，那么我们就可以由CD启动了。移除CD设备里的所有CD，重新启动系统进入BIOS或者UEFI。依照主板和所使用的系统一般是安 =DEL= ， =F1= 或者 =ESC= 进入。在BIOS或者UEFI的菜单里面，修改CD-ROM优先于硬盘启动。如果不这样修改，系统会忽略CD-ROM由硬盘启动。

#+BEGIN_QUOTE
*重要*

当安装Gentoo的目的是以使用UEFI接口替代BIOS时，建议立即由UEFI启动。如果不这么做，可能在安装完Gentoo Linux后，需要创建一个UEFI USB启动盘（或者其它媒介）。
/这段有问题/
#+END_QUOTE

现在把安装CD装入到CD-ROM里并启动。会出现一个启动提示符。在这个界面上，按 =Enter= 会以默认的选项启动系统。可以自定义启动选项，指定内核并输入 =Enter= 继续。

在启动提示符上，用户可以按显示可用内核（ =F1= ）和启动选项（ =F2= ）。如果15秒内没有选择（即没有选择内核，也没有显示信息），系统会从硬盘启动。这允许用户在不移除CD的情况下尝试他们已经安装的环境（试用于远程安装）。

我们提到的的指定内核。在安装CD上有好几种内核提供选择。默认的是gentoo。其它内核对于特殊的硬件需要用 /-nofb/ 的变种内核关闭帧缓存支持。

下面这个表格简短的列出了可用的内核。

| Kernel      | Description                                           |
|-------------+-------------------------------------------------------|
| gentoo      | 默认的内核，支持K8处理器（包含NUMA支持）和EM64T处理器 |
| gentoo-nofb | 和gentoo一样，但不支持帧缓冲                          |
| memtest86   | 测试本地RAM                                           |

和内核一起，启动选项有助于进一步优化引导过程。

|             | 硬件选项                                                                                                                                                                                                                            |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| acpi=on     | 这个选项加载ACPI，从CD启动时加载acpid服务。这只有在需要系统要求ACPI功能正常时使用，它不需要超线程支持。                                                                                                                           |
| acpi=off    | 宛全关闭ACPI。这对一些旧的硬件很有用并且是使用APM的必要条件。这也会关闭所有处理的所有超线程支持。                                                                                                                                   |
| console=X   | 这个选项是设置CD的串接设备访问，第一个选项是设备，在x86上一般是ttyS0，后面是用逗号分隔的连接选项。默认的选项是9600,8,n,1。                                                                                                          |
| dmraid=X    | 这个选项允许传递参数到RAID子系统。参数需要引号。                                                                                                                                                                                    |
| doapm       | 这个选项加载APM驱动，需要设置 =acpi=off= 。                                                                                                                                                                                         |
| dopcmcia    | 这个选项加载了PCMCIA和Cardbus硬件驱动，可以在CD启动的同时启动pcmia和cardmgr。这只在从PCMCIA/Cardbus设备启动时才需要。                                                                                                               |
| doscsi      | 这个选项支持多数的SCSI控制器。这也是启动USB设备的必要选项，因为它们使用了系统内核的SCSI子系统。                                                                                                                                     |
| sda=stroke  | 这个选项在BIOS不支持大存储器的时候，可以给整个硬盘分区。这个选项只在早期的BIOS系统中有用。在这个选项中把sda替换成需要的设备。                                                                                                       |
| ide=nodma   | 这个选项强制内核关闭DMA。并且需要一些IDE芯片组接口的CDROM驱动器，如果从IDE接口的CDROM读取信息有问题，可以试试这个选项，这同时关闭了hdparm的默认设备。                                                                               |
| noapic      | 这个选项禁用了目前只有较新的主板才有的高级可编程中断控制器，已经知道这个功能会导致一些旧设备出现问题。                                                                                                                              |
| nodetect    | 这个选项关闭了CD的自动检测功能，包括检测硬件和DHCP探测，这对调试有问题的CD或者驱动有用。                                                                                                                                            |
| nodhcp      | 这个选项关闭网卡的DHCP探测功能，这个在固定地址网络中很有用。                                                                                                                                                                        |
| nodmraid    | 这个选项关闭RAID设备映射支持，例如用于板载的IDE/SATA RAID控制器。                                                                                                                                                                   |
| nofirewire  | 这个选项关闭Firewire模块。如果在CD启动时你的Firewire引起了问题可以使用这个选项。                                                                                                                                                    |
| nogpm       | 这个选项关闭控制台gpm鼠标支持。                                                                                                                                                                                                     |
| nohotplug   | 这个选项关闭启动时热插拔和冷插拔初始化脚本。这对调试有问题的CD或驱动有用。                                                                                                                                                          |
| nokeymap    | 这个选项关闭非美国键盘的键位选择。                                                                                                                                                                                                  |
| nolapic     | 这个选项关闭单处理器内核上的APIC。                                                                                                                                                                                                  |
| nosata      | 这个选项关闭ATA系列模块。在SATA子系统出现问题时使用。                                                                                                                                                                               |
| nosmp       | 这个选项在打开SMP的内核上，关闭SMP或者对称式的多处理器功能，这对选定驱动和主板上调试SMP相关问题有用。                                                                                                                               |
| nosound     | 这个选项关闭声音支持和音量设置。对声音引起问题时有用。                                                                                                                                                                              |
| nousb       | 这个选项关闭USB模块自动加载。对调试USB问题有用。                                                                                                                                                                                    |
| slowusb     | 这在启动时为慢速USB、CDROM设备增加了一些额外的暂停，例如IBM BladeCenter。                                                                                                                                                           |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | 逻辑卷/设备管理                                                                                                                                                                                                                     |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| dolvm       | 这个选项支持Linux逻辑卷管理器。                                                                                                                                                                                                     |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | 其它选项                                                                                                                                                                                                                            |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| debug       | 打开调试代码。这会导致屏幕输出一些凌乱的信息。                                                                                                                                                                                      |
| docache     | 这个选项会把CD完整的运行时环境加载到RAM中，允许用户卸载/mnt/cdrom并加载其它CDROM。这个选项要求内存最少要有CD的两倍大。                                                                                                              |
| doload=X    | 这个选项在ramdisk初始化时加载任何模块以及依赖关系，用模块名称替换X，多个模块名用逗号分隔。                                                                                                                                          |
| dosshd      | 这个选项在启动时开启sshd，这对远程安装有用。                                                                                                                                                                                        |
| passwd=foo  | 这个选项设置root密码，当root密码是默认时对dosshd必要.                                                                                                                                                                               |
| noload=X    | 这个选项让ramdisk初始化时跳过加载可能引起问题的指定模块，语法和doload一样。                                                                                                                                                         |
| nonfs       | 这个选项在启动时关闭portmap/nfsmount。                                                                                                                                                                                              |
| nox         | 这个选项让自动启动X环境的LiveCD不自动启动X，而是使用命令行。                                                                                                                                                                        |
| scandelay   | 这个选项在启动过程暂停10秒，让一些特定的部分允许硬件慢慢进行初始化以便使用。                                                                                                                                                            |
| scandelay=X | 这个选项允许用户设置一个延时.让一些特定的部分允许硬件慢慢进行初始化以便使用。用秒数替换X。 |

#+BEGIN_QUOTE
*备注*

CD会优先检查 =no*= 选项，再检查 =do*= 选项，所以可以重写指定选项的确切顺序。
#+END_QUOTE

现在启动CD，选择一个内核和启动选项（如果默认的 =gentoo= 内核不能满足）。例如，我们用 =Gentoo= 内核和 =dopcmicia= 选项：

#+BEGIN_SRC
boot: gentoo dopcmcia
#+END_SRC

接下来用户会见到启动界面和进度条。如果用户使用的是非美式键盘，要立即按 =Alt= + =F1= 切换到确认详细模式并且提示操作。如果在10秒钟内没有进行选择，系统会用默认（美式键盘）的键位设置继续安装。一旦启动完成，用户将以超级root身份登录到“LIVE”Gentoo Linux环境。控制台会显示root提示符，可以按 =Alt= + =F2= ， =Alt= + =F3= ， =Alt= + =F4= 切换控制台。按 =Alt= + =F1= 可以回到开始的控制台。

** 额外的硬件配置

当安装CD启动时，会尝试检测所有的硬件，然后加载合适的内存模块。在大多数情况下，会工作的很顺利。然而有些情况下可能不能正常加载系统所需的模块。如果PCI自动检测漏掉了一些系统硬件，必须要手动加载合适的内核模块。

下面的例子是加载8139模块（支持某些网络接口）：

#+BEGIN_SRC
root # modprobe 8139too
#+END_SRC

** 选项：用户账户

如果其它人要进入安装环境，或者在安装CD上需要用一个普通帐户执行命令（例如用 =irssi= 聊天而为了安全原因不用root权限），那么需要新建一个用户并给root用户设置一个密码。

更改密码，用passwd程序：

#+BEGIN_SRC
root # passwd
New password: (Enter your new password)
Re-enter password: (Re-enter your password)
#+END_SRC

新建一个用户账户，首先输入权限，随后输入帐户密码。用 =useradd= 和 =passwd= 命令操作。

下面的例子，创建一个叫 /john/ 的用户：

#+BEGIN_SRC
root # useradd -m -G users john
root # passwd john
New password: (Enter john's password)
Re-enter password: (Re-enter john's password)
#+END_SRC

从root帐户（当前帐户）切换到新建账户，用 =su= 命令：

#+BEGIN_SRC
root # su - john
#+END_SRC

** 选项：在安装时查看文档

在安装的时候查看Gentoo手册，首先像上面说的那样创建一个账户。然后按 =Alt= + =F2= 切换到一个新的终端。

在安装的过程中， =links= 使用可以用来查看Gentoo手册——当然只有在网络正常工作时可用。

#+BEGIN_SRC
user $ links https://wiki.gentoo.org/wiki/Handbook:AMD64
#+END_SRC

按 =Alt= + =F1= 回到原来的终端。

** 选项：启动SSH服务

如果想在安装的过程中允许其它用户进入系统（也许是帮助安装，甚至是运程安装），需要创建一个新的帐户（见上面的文档）并且开启SSH服务。

用如下命令启动SSH服务：

#+BEGIN_SRC
root # /etc/init.d/sshd start
#+END_SRC

#+BEGIN_QUOTE
*备注*

如果用户登录到系统，他们会得到一个主机密钥（指纹）。主机密钥标识第一次登录到系统的用户。然而，稍后当系统安装完成时，有人登录到新的系统，SSH客户端为警告主机密钥已经被更改，这是因为用户已经登录了一个不同的服务器（即新的已安装的Gentoo系统而不是用于安装的Live环境），按照提示信息在客户端上替换主机密钥。
#+END_QUOTE

为了能够使用sshd，网络功能必须正常。可以继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Networking][网络配置]]。

* 自动检测网络

已经可以工作了？

如果系统已经加入到一个带有DHCP服务的以太网，网络很可能已经自动设置好了。如果是这样，那么在安装CD上许多网络命令是可以使用的，像 =ssh= 、 =scp= 、 =ping= 、 =irrssi= 、 =wget= 和 =links= 可以以立即工作。

如果网络已经成功设置， =ifconfig= 命令可以列出除 =lo= 以外的一些网络接口，例如 =eth0= ：

#+BEGIN_SRC
root # ifconfig

(...)
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11 Base address:0xe800
#+END_SRC

在系统上显示的接口名可能不同于 =eth0= 。最近安装的介质可能显示正正式的网络接口名称，像 =eno0= 、 =ens1= 或者 =enp5s0= 。你可以找到和本地网络IP地址相关的网络接口名。

在接下来的文档中，我们假设接口名为 =eth0= 。

** 选项：设置代理

如果想通过代理连接网络，那么需要在安装的时候设置一下代理，非常简单：只需要定义一个包含代理服务信息的变量就可以。

大多数情况下，定义一个服务器主机名的变量就可以了。例如，我们假设代理地址是proxy.gentoo.org端口是8080。

设置一个HTTP代理（HTTP和HTTPS协议）：

#+BEGIN_SRC
root # export http_proxy="http://proxy.gentoo.org:8080"
#+END_SRC

设置一个FTP代理：

#+BEGIN_SRC
root # export ftp_proxy="ftp://proxy.gentoo.org:8080"
#+END_SRC

设置一个RSYNC代理：

#+BEGIN_SRC
root #export RSYNC_PROXY="proxy.gentoo.org:8080"
#+END_SRC

如果代理需要用户名和密码，用下面的语法设置这个变量：

#+BEGIN_SRC
*代码* 在代理变量中加入用户名和密码

http://username:password@proxy.gentoo.org:8080
#+END_SRC

** 测试网络

尝试去侦测你网络提供商的DNS服务器（在/etc/resolv.conf中找到）和某个网站。这用来确认网络功能正常，网络数据包传输正常，DNS解析服务正常等。

#+BEGIN_SRC
root # ping -c 3 www.gentoo.org
#+END_SRC

如果一切顺利，可以跳过本章节的余下部分，直到下一步安装指令（磁盘准备）。

* 自动设置网络

如果网络不能立即工作，一些安装介质允许用户使用 =net-setup= （普通和无线网络）、 =pppoe-setup= （ADSL用户）或者 =pptp= （PPTP用户）。

如果安装介质不包括这些工具，请参看[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Manual_network_configuration][手动网络设置]]。

  - 普通的以太网用户需要用[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Default:_Using_net-setup][默认：使用net-setup]]
  - ADSL用户需要用[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Alternative:_Using_PPP][可选：使用PPP]]
  - PPTP用户需要用[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Alternative:_Using_PPTP][可选：使用PPTP]]

** 默认：使用net-setup

如果网络没有自动配置，那么用如下的 =net-setup= 脚本是配置网络最简单的方法：

#+BEGIN_SRC
root # net-setup eth0
#+END_SRC

=net-setup= 会问题一些网络环境的问题。当设置完成后网络应该可以正常工作了。用上面提到的方法测试网络。如果测试成功，那么恭喜你！跳过下面的一段直接阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks][磁盘准备]]。

如果网络依然不能工作，继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Manual_network_configuration][手动设置网络]]。

** 可选：使用PPP

如果连接网络需要PPPoE，安装CD（所有版本）简化PPP的设置。使用 =pppoe-setup= 脚本设置连接。在设置以太网设备连接到ADSL网络适配器时，需要填写用户名、密码、DNS服务的IP和基本的防火墙设置。

#+BEGIN_SRC
root # pppoe-setup
root # pppoe-start
#+END_SRC

如果出现了错误，请仔细检查etc/ppp/pap-secrets或者/etc/ppp/chap-secrets文件中的用户名和密码，并确保使用正确的以太网设备。如果没有以太网设备，需要加载合适的网络模块。这种情况下请阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Manual_network_configuration][手动设置网络]]，那里会详细解释怎么加载合适的网络模块。

如果一切正常，继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks][磁盘准备]]。

** 可选：使用PPTP

如果需要PPTP支持，使用安装CD中的 =pptpclient= 。但是首先确认网络配置正确。编辑/etc/ppp/pap-secrets或者/etc/ppp/chap-secrets，这里包含了正确的用户名和密码。

#+BEGIN_SRC
root # nano -w /etc/ppp/chap-secrets
#+END_SRC

如果需要的话调整一下/etc/ppp/options.pptp：

#+BEGIN_SRC
root # nano -w /etc/ppp/options.pptp
#+END_SRC

当一切都完成，运行 =pptp= （后面的选项不能在options.pptp里设置） 连接服务器：

#+BEGIN_SRC
root # pptp <server ip>
#+END_SRC

现在继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks][磁盘准备]]。

* 手动设置网络

** 加载合适的网络模块

当安装CD启动时，会尝试检测所有的硬件并加载相应的模块（驱动）。大多数情况下可以正常工作。然而，有时候也不能自动加载一些模块。

如果 =net-setup= 或者 =pppoe-setup= 设置失败，很可能没有检测到网卡。这意味着用户可能需要手动加载合适的内核模块。

用 =ls= 查看为网络提供的内核模块：

#+BEGIN_SRC
root # ls /lib/modules/`uname -r`/kernel/drivers/net
#+END_SRC

如果找到了适合网络设备的驱动程序，用 =modprobe= 去加载这个模块。例如，加载 =pcnet32= 模块：

#+BEGIN_SRC
root # modprobe pcnet32
#+END_SRC

查看是否检测到网卡，使用 =ifconfig= 。检测到的网卡的结果大概是下面这个样子（再说一次，eth0只是一个例子）：

#+BEGIN_SRC
root # ifconfig eth0

eth0      Link encap:Ethernet  HWaddr FE:FD:00:00:00:00
          BROADCAST NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
#+END_SRC

如果显示下这个错误，说明还是没有检测到网卡：

#+BEGIN_SRC
root # ifconfig eth0
eth0: error fetching interface information: Device not found
#+END_SRC

可以通过/sys文件查看有效的网络接口名：

#+BEGIN_SRC
root #ls /sys/class/net
dummy0  eth0  lo  sit0  tap0  wlan0
#+END_SRC

在上面这个例子，找到了6个接口。eth0比较像（有线）以太网适配器，wlan0是无线网络适配器。

假设已经检测到了网卡，再试一次 =net-setup= 或者 =pppoe-setup= （现在可以工作了），对于顶级用户我们解释怎么更好的手动配置网络。

根据你的网络选择一个章节：

  - [[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Using_DHCP][使用DHCP]] 获取IP地址
  - [[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Preparing_for_wireless_access][准备无线设置]] 如果用无线网络
  - [[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Understanding_network_terminology][了解网络术语]] 讲解基本的网络知识
  - [[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Using_ifconfig_and_route][使用ifconfig和route]] 说明怎么手动设置网络

** 使用DHCP

DHCP（动态主机设置协议）会自动获取网络信息（IP地址、子网掩码、广播地址、网关和域名服务器等）。只有当网络中有DHCP服务器（或者ISP提供DHCP服务）时才可以正确工作。用 =dhcpcd= 命令自动获取这些信息：

#+BEGIN_SRC
root # dhcpcd eth0
#+END_SRC

一些网络管理员需要知道DHCP服务的主机名和域名。这种情况可以使用：

#+BEGIN_SRC
root # dhcpcd -HD eth0
#+END_SRC

** 准备无线网络

#+BEGIN_QUOTE
*备注*

=iwconfig= 命令可能和体系结构有关。如果找不到这个命令，请参考[[ftp://ftp.linux-wlan.org/pub/linux-wlan-ng/README][linux-wlan-ng]]项目。

当使用无线网卡（802.11），在进一步设置之前要配置无线设置。可以使用 =iwconfig= 想查看当前的无线链接设置。执行 =iwconfig= 可能会显示如下信息：

#+BEGIN_SRC
root # iwconfig eth0
eth0      IEEE 802.11-DS  ESSID:"GentooNode"
          Mode:Managed  Frequency:2.442GHz  Access Point: 00:09:5B:11:CC:F2
          Bit Rate:11Mb/s   Tx-Power=20 dBm   Sensitivity=0/65535
          Retry limit:16   RTS thr:off   Fragment thr:off
          Power Management:off
          Link Quality:25/10  Signal level:-51 dBm  Noise level:-102 dBm
          Rx invalid nwid:5901 Rx invalid crypt:0 Rx invalid frag:0 Tx
          excessive retries:237 Invalid misc:350282 Missed beacon:84
#+END_SRC

#+BEGIN_QUOTE
*备注*

一些无线网卡可能不是eth0而是wlan0或者ra0。不带任何参数执行 =iwconfig= 可以找到正确的设备名称。
#+END_QUOTE

对于大多数用户，有两个重要的地址需要修改，ESSID（即无线网络名称）或者WEP密钥。如果已经列出的的ESSID和接入点不需要使用WEP，那么无线设置已经可以正常工作。

修改ESSID或者增加WEP密钥，发出如下命令。

  - 设置网络名称为GentooNode：

#+BEGIN_SRC
root # iwconfig eth0 essid GentooNode
#+END_SRC

  - 设置16进制WEP密钥：

#+BEGIN_SRC
root # iwconfig eth0 key 1234123412341234abcd
#+END_SRC

设置ASCII格式的WEP密钥，在密钥前加 =s:= ：

#+BEGIN_SRC
root # iwconfig eth0 key s:some-password
#+END_SRC

如果无线网络设置为WPA或者WPA2，那么可能需要使用 =wpa_supplicant= 。请查看[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Networking/Wireless][Gentoo手册中无线网络章节]]获取更多无线网络设置的帮助信息。

用 =iwconfig= 再次确认无线网络设置。如果无线网线已经工作，继续按照下一节的说明（[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Understanding_network_terminology][了解网络术语]]）或者使用前面所描述的 =net-setup= 配置IP级别的网络选项。

** 了解网络术语

#+BEGIN_QUOTE
*备注*

如果知道IP地址、广播地址、子网掩码和域名服务器，那个跳过这个小节继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Using_ifconfig_and_route][使用ipconfig和route]]。
#+END_QUOTE

如果上面所说的都无效，那么需要手动配置网络。这一步不是很难。但是，需要知道一些网络术语和基础知识。读完这节后，用户用户将会了解网关是什么，子网掩码是干什么的，广播地址是怎么形成的和为什么系统需要一个域名服务器。

在一个网络里，用IP（互联网协议地址）标识一个主机。这样的地址可以看做是由4个0到255的数字组成。到少在IPv4（IP第4个版本）是这样。在现实中，这样的IPv4地址由32个比特位（0或者1）组成。我们看一个例子：

#+BEGIN_SRC
*代码* IPv4地址示例

IP Address (numbers):   192.168.0.2
IP Address (bits):      11000000 10101000 00000000 00000010
                        -------- -------- -------- --------
                           192      168       0        2
#+END_SRC

#+BEGIN_QUOTE
*备注*

IPv4的继任者IPv6，使用128个比特位（0或者1）。在这一节当中，我个只讨论IPv4地址。
#+END_QUOTE

对所访问的网络而言，每台主机的IP地址都是独一无二的（即每个主机都有自已的IP地址）。为了区分主机内部网络还是外部网络，IP地址分成两个部分：网络部分和主机部分。

分离方法用子网掩码记录，子网掩码包含着1的集合后接着0的集合。网络部分可以用1集合映射得出，另一个部分就是主机部分。一般子网掩码写成IP的格式。

#+BEGIN_SRC
*代码* 网络和主机区分示例

IP address:    192      168      0         2
            11000000 10101000 00000000 00000010
Netmask:    11111111 11111111 11111111 00000000
               255      255     255        0
           +--------------------------+--------+
                    Network              Host
#+END_SRC

也就是说，192.168.0.14在这个示例网络的一部分，但是192.168.1.2不是。

广播地址是一个拥有同样网络部分的的IP，只是拥有唯一的一个IP。第个主机都会监听这个IP。他真正的用途是广播数据包。

#+BEGIN_SRC
*代码* 广播地址

IP address:    192      168      0         2
            11000000 10101000 00000000 00000010
Broadcast:  11000000 10101000 00000000 11111111
               192      168      0        255
           +--------------------------+--------+
                     Network             Host
#+END_SRC

想要上网，在网络中的每个计算都要知道哪个主机共享了网络连接。这个主机叫做网关。由于它是一个普通主机，它也有一个常规的IP（例如192.168.0.1）。

前面说每台主机都要有一个自已的IP。要想用一个名字连接这个主机，我们需要一个可以把名字（例如dev.gentoo.org）翻译成IP（64.5.62.82）的服务。我们需要在/etc/resolv.conf定义这个服务。

有些情况下，网关也提供域名解析服务。否则ISP提供的域名需要写在这个文件中。

总结，在继续前下面的信息是必要的：

| Network Item          |                        Example |
|-----------------------+--------------------------------|
| The system IP address |                    192.168.0.2 |
| Netmask               |                  255.255.255.0 |
| Broadcast             |                  192.168.0.255 |
| Gateway               |                    192.168.0.1 |
| Nameserver(s)         | 195.130.130.5, 195.130.130.133 |

** 使用ifconfig和route

设置网络有以下三步：

  1. 用 =ifconfig= 填写IP地址
  2. 用 =route= 设置网关路由
  3. 在/etc/resolv.conf填写域名解析

填写IP时，需要同时填写IP地址、广播地址、子网掩码。用有效的IP替换 =${IP_ADDR}= 、广播地址替换 =${BROADCAST}= 、 网关替换 =${NETMASK}= 执行下面的命令：

#+BEGIN_SRC
root # ifconfig eth0 ${IP_ADDR} broadcast ${BROADCAST} netmask ${NETMASK} up
#+END_SRC

用 =route= 设置路由。用有效的网关替换 =${GATEWAY}= ：

#+BEGIN_SRC
root # route add default gw ${GATEWAY}
#+END_SRC

现在打开/etc/resolv.conf文件：

#+BEGIN_SRC
root # nano -w /etc/resolv.conf
#+END_SRC

模仿下面的模板填写域名解析。确定使用有有效的域名解析地址替换 =${NAMESERVER1}= 和 =${NAMESERVER2}= ：

#+BEGIN_SRC
*代码* /etc/resolv.conf文件默认的模板

nameserver ${NAMESERVER1}
nameserver ${NAMESERVER2}
#+END_SRC

现然测试并侦测一些互联网服务（例如Google）。如果可以正常工作，那么设置完成。继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks][磁盘准备。]]

* 块设备简介

** 块设备

让我们看一看Gentoo Linux磁盘方面的问题，包括文件系统、分区和块设备。一旦理解了文件系统的来龙去脉，我们就会为Gentoo Linux设置分区和文件系统。

开始，我们先看看块设备。最知名的块设备可能是Linux系统的第一个驱动器/dev/sda。SCSI和串口ATA都标记为/dev/sd*；在新的内核的libata架构下IDE设备也被标记为/dev/sd*。如果用老的硬件架构，第一个IDE设备是/dev/hda。

上面介绍的块设备代表磁盘的抽象接口。用户可以使用块设备编写读写磁盘的程序，不需要关注是使用的IDE、SCSI或者其它的什么设备。程序可以简单的以连续的数据或者随机的512字节来定位存储数据。

** 分区

尽管理论上可以使用整个磁盘来存储Linux系统，但在实际上几乎从不这样做。我们经常把磁盘分成较小的可以更方便管理的块设备。在AMD64系统上，这个操作叫做分区。有两个标准的分区技术可以使用：MBR和GPT。

*** MBR

MBR（主引导记录）用32位标识符表示起始扇区和分区长度，支持3种分区类型：主分区，扩展分区和逻辑分区。主分区把信息存储在自已的MBR中——在磁盘开始位置的一个很小的区域（通常是512字节）。因为这个空间很小，所以只支持4个主分区（例如/dev/sda1到/dev/sda4）。

要想支持更多分区，其中一个主分区可以标记为扩展分区。这个分区可以包含一些逻辑分区（分区中的分区）。

第个分区被限制为2TB之内（因为32位标识符）。MBR不提供备份机制，所以如果有应用破坏了MBR，所有的分区信息都会丢失。

*** GPT

GPT（全局唯一标识分区表）使用64位标识符标识分区，其中存储分区信息的位置也要比512字节的MBR大的多，也没有限制分区的数量。同时，分区也可以更大（大概8ZB）。

当使用UEFI（替换BIOS）和操作系统进行交互时，几乎必须使用GPT，因为MBR有一些兼容性问题。

GPT有更先进的功能，它可以在磁盘末尾备份分区表，它可以覆盖磁盘开头已损坏的GPT信息。GPT使用CRC32校验来检测分区表错误。

** GPT还是MBR

在上面的说明中，有人可能会想更建议使用GPT。但是还有一警告。

在运行BIOS系统的计算机上使用GPT，不能实现Windows双系统启动。因为检测到GPT分区表后Windows会以EFI模式启动。

当一些有缺陷的BIOS或者EFI，配置以BIOS/CSM/传统模式启动时，可能会在GPT分区磁盘上产生问题。如果这样的话，可以通过 =fdisk= 和 =-t dos= 强制用MBR格式读这个分区表，并在这个分区表上设置boot/active标记解决这个问题。

这种情况下，启动 =fdisk= 在第一个分区（ =1= ）用 =a= 切换标记。用 =w= 保存修改并退出 =fdisk= ：

#+BEGIN_SRC
user $ fdisk -t dos /dev/sda
Welcome to fdisk (util-linux 2.24.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): a
Partition number (1-4): 1

Command (m for help): w
#+END_SRC

** 使用UEFI

当使用UEFI（替代BIOS）启动操作系统来安装Gentoo，创建一个EFI系统分区是很重要的。接下来的指令是要点。

EFI系统分区需要分区为FAT32格式（或者在Linux系统上显示为vfat的格式）。这节的末尾使用ext2文件系统的例子创建boot分区。用下面的方法确定使用vfat格式：

#+BEGIN_SRC
root # mkfs.vfat /dev/sda2
#+END_SRC

#+BEGIN_QUOTE
*警告*

如果boot分区不使用FAT32（vfat）文件系统，那么UEFI固件将找不到Linux内核，造成不能启动！
#+END_QUOTE

** 高级存储

AMD64安装CD支持LVM2。LVM2增加了系统分区的灵活性。在安装的过程中，我们关注“常规”分区，但是了解LVM2也是很有用的。

*** 默认的分区方案

我们使用下面的分区方案贯穿整个手册的剩余部分。如果这个方案足够用户使用，可以跳到[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Default:_Using_parted_to_partition_the_disk][默认：使用parted进行磁盘分区]]或者[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Alternative:_Using_fdisk_to_partition_the_disk][可选：使用fdisk进行磁盘分区。两个都是磁盘分区工具，]] =fdisk= 是知名且稳定分区工具，建议在MBR分区上使用。 =parted= 是刚出现的分区工具，建议在GPT分区使用。

| Partition | Filesystem     | Size             | Description         |
|-----------+----------------+------------------+---------------------|
| /dev/sda1 | (bootloader)   | 2M               | BIOS boot partition |
| /dev/sda2 | ext2 (or vfat) | 128M             | Boot partition      |
| /dev/sda3 | (swap)         | 512M or higher   | Swap partition      |
| /dev/sda4 | ext4           | Rest of the disk | Root partition      |

在执行创建分区命令前，第一组章节会介绍更多关于分区方案和相关的问题。

* 设计一个分区方案

** 多少和多大

分区的数量依赖于使用环境，例如，如果有很多用户，那么建议设置 ~/home/~ 分区增加安全性并且容易备份。如果把Gentoo当做邮件服务器使用，那么应该设置 ~/var/~ 分区来保存所有的邮件。然后文件系统的选择将会提高系统性能。游戏服务器需要把游戏服务安装到 ~/opt/~ 分区中。和 ~/home/~ 分区的原因一样：安全并且容易备份。大多数情况下， ~/usr/~ 分区要大点：它不只是包含主要的应用程序，还包括了大概500M的Portage树文件，而且还没算各种数据源。

像我们看到的，分区依赖于管理员的目标。分区的建议如下：

  - 每个分区或卷选择性能最好的文件系统
  - 如果一个废弃的工具连续向分区或者卷写入数据，系统不会耗尽其它分区的剩余空间
  - 如果需要，可以减少文件系统检查，多个文件检查可以并行（虽然这个功能在多磁盘比多分区效果更好）
  - 挂在只读分区或者卷可以提升安全性， =nosuid= （忽略setuid特性）， =noexec= （忽略执行特性）等

虽然，多分区也有缺点。如果配置不当，系统可能在某个分区空间耗尽时，另一个分区却有很多剩余空间，另一个问题是——特别是比较重要的挂在点 ~/usr/~ 或者 ~/var/~ ——管理员经常需要在其它启动脚本开始前，先用已经初始化的文件系统挂在分区。虽然不总是这样，但是结果可能有所不同。

除非使用GPT标签，否则SCSI和SATA最多只能有15个分区。

** 交换空间

交换空间没有完美的大小。交换空间的目的是当内存用尽的时候，保存内核中的数据。交换空间允许内核将不需要马上使用的内存页存储到磁盘上，从而释放内存。当然，如果突然需要这段内存，这些用一些时间把内存页会重新读回内存（磁盘比内存要慢的多）。

当系统不使用内存密集型应用，或者系统有很多内存，那么基本不需要很大的交换空间。然而，交换空间还用于在休眠情况下存储整个内存。如果系统需要休眠，那么需要大点的交换空间，通常最小的交换空间也得和系统内存一样大。

** 什么是BIOS启动分区

BIOS启动分区是一个很小的分区（1MB到2MB），它保存GRUB2的一些附加数据，这些数据分配空间（MBR标签的情况下有几百个字节）也不能放到其它位置。

考虑到低空间消耗或者需要记录的分区差异过多，我们不需要BIOS分区。其它情况下我们建议创建这个分区。

为了完整起见，当我们使用GPT标签和GRUB2时，需要创建BIOS分区，或者在使用MBR标签和GRUB2，第一个分区开始的位置在磁盘开始处1MB时，我们也需要BIOS分区。

* 默认：使用parted进行磁盘分区

在这一章，我们会使用前面提到的分区布局：

| Partition | Description         |
|-----------+---------------------|
| /dev/sda1 | BIOS boot partition |
| /dev/sda2 | Boot partition      |
| /dev/sda3 | Swap partition      |
| /dev/sda4 | Root partition      |

用户可以根据偏好修改自己的分区表。

** 用parted查看当前的分区表

=parted= 程序为分区提供了一个简单的接口，并且支持大分区（大于2TB）。在磁盘上启动 =parted= （在我们的例子中，使用 /dev/sda）。建议使用 =parted= 进行最优的磁盘分区对齐：

#+BEGIN_SRC
root # parted -a optimal /dev/sda
GNU Parted 2.3
Using /dev/sda
Welcome to GNU Parted! Type 'help' to view a list of commands.
#+END_SRC

对齐就是说磁盘上的分区开始于一个知名的位置，以确保磁盘操作，使用系统级操作（获取磁盘页面），这会尽量的少的使用内置磁盘操作。当系统要求获取一个页面时，没对齐的分区可能会要求磁盘获取两个页面，即使系统只要求一个。

输入 =help= 并按回车，查看parted的所有选项。

** 设置GPT标签

许多x86/amd64上的磁盘默认的是msdos标签。使用 =parted= ，设置GPT标签的命令是 =mklabel gpt= 。

#+BEGIN_QUOTE
*警告*

修改分区类型会删除磁盘上的所有分区。磁盘里的所有数据将会丢失。

#+BEGIN_SRC
(parted) mklabel gpt
#+END_SRC

使用 =mklabel msdos= 设置MBR标签。

** 用parted删除所有分区

如果还没有完事儿（例如刚刚 =mklabel= 操作，或者因为磁盘是刚格式化过的），首先从磁盘删除所有分区。输入 =print= 查看当前分区，再输入 =rm NUMBER= 删除分区。

#+BEGIN_SRC
(parted) rm 2
#+END_SRC

不需要所有的分区都这么操作，不管怎么样，一定要确认不要犯任何错误——parted会立即执行修改（不像 =fdisk= 那样，在保存之前允许用户撤销修改或者退出）。

** 创建分区

现在创建分区。用 =parted= 创建分区很简单——我们需要做的就是通知 =parted= 如下设置：

  - 使用的分区类型。这个通常很重要。如果使用msdos分区标签，请记住最多只能有4个主分区。如果需要超过4个分区，把4个分区中的第一个分区改为扩展分区，并在扩展分区中建立逻辑分区
  - 分区开始位置（可以用MB，GB，等表示）
  - 分区结束位置（可以用MB，GB，等表示）

首先，告诉parted我们使用Megabytes单位（实际上是mebibytes，标准上缩写为MiB符号，但是在文本中我们使用更通用的MB）：

#+BEGIN_SRC
(parted) unit mib
#+END_SRC

现在创建一个2MB的分区一会儿用于GRUB2启动器。用 =mkpart= 命令通知 =mkpart= 开始于1MB并结束于3 MB（创建一个2 MB的分区）。

#+BEGIN_SRC
(parted) mkpart primary 1 3
(parted) name 1 grub
(parted) set 1 bios_grub on
(parted) print

Model: Virtio Block Device (virtblk)
Disk /dev/sda: 20480MiB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number   Start      End      Size     File system  Name   Flags
 1       1.00MiB    3.00MiB  2.00MiB               grub   bios_grub
#+END_SRC

用同样的方法创建boot分区（128 MB），交换分区（在例子中，512 MB），和用剩下的空间建立root分区（结束位置用-1标记，意思是磁盘末尾减1MB，这是最大分区的建立方法）。

#+BEGIN_SRC
(parted) mkpart primary 3 131
(parted) name 2 boot
(parted) mkpart primary 131 643
(parted) name 3 swap
(parted) mkpart primary 643 -1
(parted) name 4 rootfs
#+END_SRC

当使用UEFI接口来启动系统（替代BIOS），标记boot分区为EFI系统分区。当启动选项设置在分区上parted会自动这样设置。

#+BEGIN_SRC
(parted) set 2 boot on
#+END_SRC

最后的结果像下面这样：

#+BEGIN_SRC
(parted) print
Model: Virtio Block Device (virtblk)
Disk /dev/sda: 20480MiB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number   Start      End      Size     File system  Name   Flags
 1       1.00MiB    3.00MiB  2.00MiB               grub   bios_grub
 2       3.00MiB    131MiB   128MiB                boot
 3       131MiB     643MiB   512MiB                swap
 4       643MiB     20479MiB 19836MiB              rootfs
#+END_SRC

#+BEGIN_QUOTE
*备注*

在UEFI接口下安装，启动标识会在boot分区上显示。
#+END_QUOTE

使用 =quit= 退出parted。

* 可选：使用fdisk进行磁盘分区

#+BEGIN_QUOTE
*备注*

虽然近期的fdisk版本可以支持GPT，但是还有一些问题。下面的安装命令假设用户使用的MBR分区表。
#+END_QUOTE

下面这部分会解释怎么用 =fdisk= 进行示例分区。前面提到的样例分区表如下：

| Partition | Description  |
|-----------+--------------|
| /dev/sda1 | BIOS启动分区 |
| /dev/sda2 | 启动分区     |
| /dev/sda3 | 交换分区     |
| /dev/sda4 | 主分区       |

用户可以根据偏好修改分区表。

** 查看当前分区表

=fdisk= 是一个很流行的磁盘分区软件。对磁盘启动 =fdisk= （在我们的示例中使用/dev/sda）：

#+BEGIN_SRC
root # fdisk /dev/sda
#+END_SRC

#+BEGIN_QUOTE
*备注*

使用 =-t gpt= 来支持GPT。建议密切关注fdisk的输出，以防止fdisk近期的发展改变了默认为MBR的情况。余下的章节假设使用MBR表。
#+END_QUOTE

输入 =p= 来查看当前的分区配置：

#+BEGIN_SRC
Command (m for help): p
Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/sda1   *         1        14    105808+  83  Linux
/dev/sda2            15        49    264600   82  Linux swap
/dev/sda3            50        70    158760   83  Linux
/dev/sda4            71      2184  15981840    5  Extended
/dev/sda5            71       209   1050808+  83  Linux
/dev/sda6           210       348   1050808+  83  Linux
/dev/sda7           349       626   2101648+  83  Linux
/dev/sda8           627       904   2101648+  83  Linux
/dev/sda9           905      2184   9676768+  83  Linux
#+END_SRC

这个磁盘配置安装了7个Linux文件系统（每个分区都用“linux”标识）以及一个交换分区（用“Linux swap”标识）。

** 用fdisk删除所有分区

首先删除磁盘所有的分区。输入 =d= 删除分区。例如，删除/dev/sda1：

#+BEGIN_SRC
Command (m for help): d
Partition number (1-4): 1
#+END_SRC

分区已经设置为计划删除。输出分区列表时不会显示这个分区（ =p= ）, 直到保存修改前，它的数据不会被擦除。这允许用户输入错的情况下终止操作——输入错了的话，输入 =q= 并按回车不保存修改立即退出程序。

重按 =p= 输出分区列表，输入 =d= 和分区序号来删除分区。直到分区列表为空：

#+BEGIN_SRC
Command (m for help): p
Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
#+END_SRC

现在内存中的分区列表为空，我们准备新建分区。

** 新建BIOS启动分区

首先新建一个小的BIOS启动分区。输入 =n= 新建分区，输入 =p= 选择主分区，输入 =1= 表示建立第一个主分区。当提示第一个扇区，确定他开始于2048（boot loader指定）按回车。当提输入最后一个扇区，输入+2M新建一个2 Mb的分区：

#+BEGIN_QUOTE
*备注*

在启动引导器不能正确检查这是个分区时，从2048扇区开始是不够安全。
#+END_QUOTE

#+BEGIN_SRC
Command (m for help): n
Command action
  e   extended
  p   primary partition (1-4)
p
Partition number (1-4): 1
First sector (64-10486533532, default 64): 2048
Last sector, +sectors +size{M,K,G} (4096-10486533532, default 10486533532): +2M
#+END_SRC

标记分区为EFI系统：

#+BEGIN_SRC
Command (m for help): t
Selected partition 1
Hex code (type L to list codes): ef
Changed system type of partition 1 to ef (EFI (FAT-12/16/32))
#+END_SRC

#+BEGIN_QUOTE
*备注*

不鼓励EFI系统和MBR分区一起使用。如果使用有EFI功能的系统，请使用GPT表。
#+END_QUOTE

** 创建启动分区

现在创建一个小的启动分区。输入 =n= 新建分区，输入 =p= 选择主分区，输入 =2= 建立第二个主分区。当提示输入首扇区，按 =Enter= 默认。当提示输入最后一个扇区，输入+128M建立一个128MB的分区：

#+BEGIN_SRC
Command (m for help): n
Command action
  e   extended
  p   primary partition (1-4)
p
Partition number (1-4): 2
First sector (5198-10486533532, default 5198): (Hit enter)
Last sector, +sectors +size{M,K,G} (4096-10486533532, default 10486533532): +128M
#+END_SRC

现在输入 =p= 输出如下：

输入 =a= 选择 =2= 切换可启动标记，再次输入 =p= ，请注意“Boot”列中多了一个*号。

** 创建交换分区

要想创建交换分区，先输入 =n= 新建一个分区，然后输入 =p= 让fdisk知道这是个主分区。输入 =3= 建立第三个主分区/dev/sda3。当提示输入首扇区时，按 =Enter= 默认。当提示输入最后一个扇区，输入+512M（或者所需的交换分区大小）建立一个512MB的分区。

完成后，输入 =t= 设置分区类型， 输入 =3= 选择刚刚建立的分区，输入 /82/ 选择“Linux Swap”类型。

** 创建主分区

最后创建主分区，输入 =n= 新建一个分区， 输入 =p= 选择主分区，输入 =4= 建立第四个主分区/dev/sda4。当提示输入首扇区，按回车默认。当提示入尾扇区，按回车使用磁盘剩余空间。完成后输入 =p= 可以显示分区列表：

#+BEGIN_SRC
Command (m for help): p
Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1         3      5198+  ef  EFI (FAT-12/16/32)
/dev/sda2   *         3        14    105808+  83  Linux
/dev/sda3            15        81    506520   82  Linux swap
/dev/sda4            82      3876  28690200   83  Linux
#+END_SRC

** 保存分区表

输入 =w= 保存并退出 =fdisk= 。

#+BEGIN_SRC
Command (m for help): w
#+END_SRC

创建完分区后，该是建立文件系统的时候了。

* 建立文件系统

** 简介

现在已经创建了分区，应该设置一个文件系统。在下面一节中介绍了多种Linux支持的文件系统。如用户已经知道要使用哪种文件系统，可以跳到[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Applying_a_filesystem_to_a_partition][分区使用文件系统继续阅读。其它用户需要先了解一些文件系统知识。]]

** 文件系统

有好多种文件系统可以选择。有一些文件系统在amd64架构下表现比较稳定——在重要的分区使用文件系统前，请仔细研究文件系统知识。

*ext2*

  这个文件系统可以成为正式的Linux文件系统，但是它没有元数据日志，这意味着ext2文件系统启动时非常耗时。现在已经有很多新一代的日志文件系统可以这种非日志的系统。这种系统可以快速检查一致性，防止在文件系统启动发现不一致时出现较长时间的延迟。

*ext3*

  ext2文件系统的日志功能版本，除子提供可以快速恢复的元数据日志功能外，还提升了例如完整数据和指令数据的日志模式。它使用HTree索引可以在基本所有状态表现优异。简而言之，ext3是一个可靠的文件系统。

*ext4*

  作为ext3的分支版本，ext4有很多新的功能，提升了性能并适当的移除了大小限制。可以让卷的大小达到1EB，文件大小达到16TB。用extents替代了ext2/ext3经典的bitmap块分配方式，这种方式可以提升大文件的读写性能并减少磁盘碎片。Ext4提供了复杂的块分配算法（延迟分配和多块分配），可以让文件系统驱动用很多法调优数据表现。推荐所有通用平台都使用Ext4文件系统。

*JFS*

  IBM的高性能日志文件系统。JFS是基于B+树的一个轻量级、快速并且可信赖的文件系统，它可以在很多情况下表现良好。

*ReiserFS*

  基于B+树的日志文件系统，总体性能不错，特别是处理消耗CPU时间的很多小文件时。ReiserFS照比其它文件系统更容易维护。

*XFS*

  一个有元数据日志功能的文件系统，它有更健壮的功能可以对scalability优化。XFS看上去不能很好的处理各种硬件问题。

*vfat*

  也被称为FAT32，Linux支持这种文件系统，但是它不支持权限设置。它经常用于其它操作系统（主要是Microsoft Windows），但也是一些固件系统（比如UEFI）所必须的文件系统。


如果在小分区（小于8GB）上使用ext2，ext3或者ext4文件系统时，那么需要用合适的参数创建文件系统来保留足够的索引节点。 =mke2fs= 应用使用“多少字节一个索引节点”来计算文件系统需要多少索引节点。在较小的分区上，建议增加计算出的节点数量。

ext2文件系统使用如下命令：

#+BEGIN_SRC
root # mke2fs -T small /dev/<device>
#+END_SRC

ext3和ext4文件系统，增加 =-j= 选项打开日志功能：

#+BEGIN_SRC
root # mke2fs -j -T small /dev/<device>
#+END_SRC

这将生成文件系统索引节点的四倍数量，“多少个字节一个索引节点”，从16KB减小到4KB每个索引节点。可以通过提供一个比例进一步调整：

#+BEGIN_SRC
root # mke2fs -i <ratio> /dev/<device>
#+END_SRC

** 分区使用文件系统

有很多工具可以在分区或卷上创建文件系统：

| Filesystem | Creation Command |
|------------+------------------|
| ext2       | mkfs.ext2        |
| ext3       | mkfs.ext3        |
| ext4       | mkfs.ext4        |
| reiserfs   | mkreiserfs       |
| xfs        | mkfs.xfs         |
| jfs        | mkfs.jfs         |
| vfat       | mkfs.vfat        |

例如，设置启动分区（/dev/sda2）为ext2，主分区（/dev/sda4）为ext4。可以用如下命令：

#+BEGIN_SRC
root # mkfs.ext2 /dev/sda2
root # mkfs.ext4 /dev/sda4
#+END_SRC

现在在新建的分区（或逻辑卷）上创建文件系统。

** 激活交换分区

=mkswap= 是一个初始化交换分区的命令：

#+BEGIN_SRC
root # mkswap /dev/sda3
#+END_SRC

=swapon= 用来激活交换分区：

#+BEGIN_SRC
root #swapon /dev/sda3
#+END_SRC

用上面提到的命令创建并激活交换分区。


----------------------------
译注：
partition table : 分区列表
partition layout : 分区表
reader : 用户
