#+TITLE: Gentoo Linux amd64 手册: 安装Gentoo
#+SETUPFILE:readtheorg.setup
* 序言

** 欢迎

首先，欢迎来到Gentoo。您将进入选择和性能的世界。Gentoo处处都是选择。当安装Gentoo时，这点你会感受到好几次，用户可以选择编译多少软件，怎么安装，系统使用什么系统日志程序等，等等。

Gentoo是一个快速而先进的元发行版本，它有着简洁和灵活的设计理念。Gentoo是由自由软件编译而成，它不向用户隐藏任何东西。Gentoo使用Portage进行软件包管理，它用Python编写而成，用户可以轻松的查看和修改源代码。Gentoo软件包管理系统使用源代码（虽然也支持预编译软件包）进行管理，配置文件使用普通的文本文件。也就是说，处处都是开放的。

让用户明白怎么选择可以运行Gentoo是非常重要的。我们不会强迫用户做他们不喜欢的事情，如果你觉得我有的话，请[[https://bugs.gentoo.org/][告诉]]我们。

** 安装的结构

Gentoo的安装可以视为10个步骤，依照下面的步骤，可以达到相应的状态。

  1. 第1步后，用户处在一个准备安装Gentoo的环境中
  2. 第2步后，已经准备好用于安装Gentoo的网络环境
  3. 第3步后，硬盘初始化完毕，可以用于安装Gentoo
  4. 第4步后，系统环境就绪，用户准备改变根目录到新的环境中
  5. 第5步后，所有Gentoo都要安装的核心软件包已经安装完毕
  6. 第6步后，Linux内核安装完毕
  7. 第7步后，用户已经配置好了大部分Gentoo配置文件
  8. 第8步后，已经安装好必要的软件
  9. 第9步后，已经安装并配置好bootloader
  10. 第10步后，Gentoo环境安装成功，已经可以开始使用了

当做出一个特定的选择时，手册会解释利与弊。虽然有一个默认的选择用于继续（在标题中用“默认：”标识），同时也会提供其它的可能（在标题中用“选择：”标识），不要认为默认是Gentoo推荐的设置，其实只是Gentoo认为大多数用户会选择它。

有一些并不是安装Gentoo所必须的可选的步骤，这些步骤用“选项：”标识。有一些选项依赖于之前的操作，不用担心，在做出选择时和可选步骤前，我们都会有相应的提示。

** 怎么选择

Gentoo可以用很多方式进行安装。可以通过下载Gentoo光盘安装，可以通过一个安装好的发行版进行安装，从一个不是Gentoo（例如Knoppix）的启动光盘进行安装，从网络安装，从急救光盘安装，等。

本文档包含了通过安装光盘安装，同时也包含了一些网络安装的方法。

#+BEGIN_QUOTE
*备注*

其它方式安装的帮助，包括非Gentoo安装光盘的安装方法，请查看[[https://wiki.gentoo.org/wiki/Installation_alternatives][其它安装指南]]
#+END_QUOTE

我们也提供了一个可能很有用的[[https://wiki.gentoo.org/wiki/Gentoo_installation_tips_and_tricks][Gentoo安装提示和技巧]]文档供你参考。

** 困难

如果你在安装的时候（或者在安装文档）发现了问题，请访问我们的[[https://bugs.gentoo.org/][bug追踪系统]]查看这个问题是否已经提交。如果还没有存在请提交一个bug报告给我们，我们会注意它。不要害怕负责你的bug的开发人员，他们不会吃人的。

可能你注意到，这个文档已经结构化了，包含了结构化文档的其它链接。这是因为Gentoo的手册使用了大量的源代码（也是为了减少文档的复杂度和提高使用效率）。我们会尽量保证不会让你困惑。

如果有一些不确定是用户问题（尽管用户已经仔细的阅读了手册）还是系统问题（尽管我们已经仔细的测试过这些文档），我们欢迎任何人人加入在irc.freenode.net上的#gentoo频道。当然，也欢迎加入其它的关于Gentoo的频道。

说到这，如果有其它关于Gentoo的问题，请看[[https://wiki.gentoo.org/wiki/Main_Page][Gentoo Wiki]]里的[[https://wiki.gentoo.org/wiki/FAQ][常见问题]]，[[https://forums.gentoo.org/][Gentoo论坛]]上也有[[https://forums.gentoo.org/viewforum.php?f%3D40][FAQs]]。

* 硬件需求

在开始前，我们列出了成功安装Gentoo amd64的硬件需求。

|           | Minimal CD                                                          | LiveDVD |
| CPU       | Any AMD64 CPU or [[http://en.wikipedia.org/wiki/EMT64#Intel_64][EM64T]] CPU (Core 2 Duo & Quad processors are EM64T) |         |
| Memory    | 256 MB                                                              | 512 MB  |
| Diskspace | 2.5 GB (excluding swap space)                                       |         |
| Swapspace | At least 256 MB                                                     |         |

[[https://www.gentoo.org/proj/en/base/amd64/][Gentoo AMD64 项目站点]]有更多关于Gentoo AMD64的信息。

* Gentoo安装CD

** 最小安装CD

Gentoo最小安装CD是一个包含自支持环境Gentoo系统。用户可以从CD中启动，在启动的过程中系统会自动加载合适的硬件驱动。这个CD由Gentoo开发者负责维护，供用户在有网络链接的情况下安装Gentoo。

最小安装CD的文件名为 /install-amd64-minimal-<release>.iso/ 。

** 临时LiveDVD

有时候，Gentoo Ten项目会精心制作一个用于安装Gentoo的特别DVD版本。进一步减少安装步骤，可能和最小安装CD有一点不一样。然而，LiveDVD（或者其它的可启动的Linux环境）可能通过在终端输入 =sudo su -= 或者 =sudo -i= 来获取root权限。

** 用什么stages

stage3是一个包含最小Gentoo环境的存档。适用本文档里的指令去安装Gentoo。以前，Gentoo手册说过可以使用3个包中的一个进行安装。虽然Gentoo依然支持stage1和stage2存档包进行安装，但正式的安装方法是用stage3进行安装。如果你对stage1和stage2安装感兴趣，请阅读Gentoo FAQ里的[[https://wiki.gentoo.org/wiki/FAQ#How_do_I_Install_Gentoo_Using_a_Stage1_or_Stage2_Tarball.3F][怎么用Stage1和Stage2安装Gentoo]]？

Gentoo安装CD不提供Stage3，用户可以去任何一个[[https://www.gentoo.org/downloads/mirrors/][正式Gentoo镜像]]，releases/amd64/autobuilds目录下载Stage3。

* 下载和烧录CD

** 下载媒体

Gentoo默认的安装媒体是最小安装CD，他是一个包含正确工具的可自启动的Gentoo Linux环境。有很多镜像可以下载这个CD。

在这些镜像中，你可以按如下路径找到最小安装CD：

  1. 找到releases/目录
  2. 选择正确的架构，例如amd64
  3. 选择autobuilds/目录
  4. 选择current-iso/目录

在这个位置，安装CD文件以.iso后缀。例如，请看下面这个列表：

#+BEGIN_SRC
CODE Example list of downloadable files at releases/amd64/autobuilds/current-iso/

[DIR] hardened/                                         05-Dec-2014 01:42 -
[   ] install-amd64-minimal-20141204.iso                04-Dec-2014 21:04 208M
[   ] install-amd64-minimal-20141204.iso.CONTENTS       04-Dec-2014 21:04 3.0K
[   ] install-amd64-minimal-20141204.iso.DIGESTS        04-Dec-2014 21:04 740
[TXT] install-amd64-minimal-20141204.iso.DIGESTS.asc    05-Dec-2014 01:42 1.6K
[   ] stage3-amd64-20141204.tar.bz2                     04-Dec-2014 21:04 198M
[   ] stage3-amd64-20141204.tar.bz2.CONTENTS            04-Dec-2014 21:04 4.6M
[   ] stage3-amd64-20141204.tar.bz2.DIGESTS             04-Dec-2014 21:04 720
[TXT] stage3-amd64-20141204.tar.bz2.DIGESTS.asc         05-Dec-2014 01:42 1.5K
#+END_SRC

在上面的例子中，install-amd64-minimal-20141204.iso文件就是最小安装CD。你也可以看到一些其它相关的文件：

  - A.CONTENTS文件是一个列出了安装CD中所有文件的文本文件。
  - A.DIGESTS文件包含了ISO文件的HASH值，这个文件可以用来验证下载的映像是否损坏。
  - A.DIGESTS.asc文件不只包含了ISO文件的HASH值（像.DIGESTS文件那样），还加密了那个文件的签名信息。这个文件不仅能验证文件是否损坏，还能验证是否是Gentoo团队释出的版本，以防止被它人篡改。

现在先忽略其它文件-接下来的安装中会用到他们时再说。先下载ISO映像，如果你想验证文件可靠性，也可以下载.DIGESTS.asc文件。我们不需要下载在接下来的安装中我们不用的.CONTENTS文件和.DIGESTS文件，因为我们已经有了加密了签名信息的.DIGESTS.asc文件。

** 验证下载文件

#+BGEIN_QUOTE
*备注*

在安装Gentoo Linux时，这是一个可选的步骤，但是还是推荐验证下载的文件以确保文件是由Gentoo团队提供的映像。
#+END_QUOTE

用合适的工具通过.DIGESTS和.DIGESTS.asc文件去验证ISO文件的正确性，验证的步骤如下：

  1. 对数字签名进行验证，以确保是由Gentoo团队提供的安装文件
  2. 如果数字签名验证正确，那么校验文件是否被损坏

*** Windows验证

在Windows系统中，不太容易在系统中找到合适的验证和数字签名工具。

验证数字签名的工具可以使用[[http://www.gpg4win.org/][GPG4Win]]，安装完成后，先导入Gentoo团队的公钥，密钥列表可以在[[https://www.gentoo.org/downloads/signatures/][签名页面]]找到。导入后用户可以用.DIGESTS.asc文件进行验证。

#+BEGIN_QUOTE
*重要*

这里是用.DIGESTS.asc文件验证而不是用.DIGESTS文件进行证。这也是为什么上面的说明只要求下载.DIESTS.asc文件。
#+END_QUOTE

校验文件可以使用[[http://www.sinf.gr/en/hashcalc.html][Hashcalc application]]，不过也有其它的一些工具可以使用，大多时候那些工具会显示文件的校验值，需要用户去核对.DIGESTS.asc文件里的校验值。

*** Linux验证

在Linux系统，通用的验证数字签名的方法是使用[[http://packages.gentoo.org/package/app-crypt/gnupg][app-crypt/gnupg软件。]]安装好软件后，可以用如下的命令通过.DIGESTS.asc文件来验证数字签名。

首先，下[[https://www.gentoo.org/downloads/signatures/][密钥页面]]上正确的密钥：

#+BEGIN_SRC
user $ gpg --recv-keys 0xBB572E0E2D182910

gpg: requesting key 0xBB572E0E2D182910 from hkp server pool.sks-keyservers.net
gpg: key 0xBB572E0E2D182910: "Gentoo Linux Release Engineering (Automated Weekly Release Key) <releng@gentoo.org>" 1 new signature
gpg: 3 marginal(s) needed, 1 complete(s) needed, classic trust model
gpg: depth: 0  valid:   3  signed:  20  trust: 0-, 0q, 0n, 0m, 0f, 3u
gpg: depth: 1  valid:  20  signed:  12  trust: 9-, 0q, 0n, 9m, 2f, 0u
gpg: next trustdb check due at 2018-09-15
gpg: Total number processed: 1
gpg:         new signatures: 1
#+END_SRC

然后，验证.DIGESTS.asc文件中的数字签名：

#+BEGIN_SRC
user $ gpg --verify install-amd64-minimal-20141204.iso.DIGESTS.asc

gpg: Signature made Fri 05 Dec 2014 02:42:44 AM CET
gpg:                using RSA key 0xBB572E0E2D182910
gpg: Good signature from "Gentoo Linux Release Engineering (Automated Weekly Release Key) <releng@gentoo.org>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 13EB BDBE DE7A 1277 5DFD  B1BA BB57 2E0E 2D18 2910
#+END_SRC

确认签名正确性，需要在[[https://www.gentoo.org/downloads/signatures/][Gentoo密钥页面]]上核对指纹。

验证完数字签名后，下一步校验ISO文件完整性。.DIGESTS.asc文件包含多种HASH算法的校验值，所以验证文件完整性的方法是确认在.DIGESTS.asc文件中某算法的值，例如SHA512校验：

#+BEGIN_SRC
user $ grep -A 1 -i sha512 install-amd64-minimal-20141204.iso.DIGESTS.asc

# SHA512 HASH
364d32c4f8420605f8a9fa3a0fc55864d5b0d1af11aa62b7a4d4699a427e5144b2d918225dfb7c5dec8d3f0fe2cddb7cc306da6f0cef4f01abec33eec74f3024  install-amd64-minimal-20141204.iso
--
# SHA512 HASH
0719a8954dc7432750de2e3076c8b843a2c79f5e60defe43fcca8c32ab26681dfb9898b102e211174a895ff4c8c41ddd9e9a00ad6434d36c68d74bd02f19b57f  install-amd64-minimal-20141204.iso.CONTENTS
#+END_SRC

上面的输出显示了两个SHA512校验值，一个是install-amd64-minimal-20141204.iso文件的校验值，一个是对应的.CONTENTS文件的校验值。我们只需要第一个值和我们计算的文件的校验值进行对比，我们可以用如下的命令去计算文件校验值：

#+BEGIN_SRC
user $ sha512sum install-amd64-minimal-20141204.iso

364d32c4f8420605f8a9fa3a0fc55864d5b0d1af11aa62b7a4d4699a427e5144b2d918225dfb7c5dec8d3f0fe2cddb7cc306da6f0cef4f01abec33eec74f3024  install-amd64-minimal-20141204.iso
#+END_SRC

如果两个校验值相同，那么我们可以确认文件没有损坏并继续安装。

** 刻录

当然，只是下载完ISO文件，Gentoo Linux安装程序不会自动启动，ISO文件需要刻录到CD中并启动，我们需要把ISO文件的内容记录到CD中，而不是ISO文件本身。下面所说的是一些简单方法—更详细的指令可以查看[[https://wiki.gentoo.org/wiki/FAQ#How_do_I_burn_an_ISO_file.3F][记录ISO文件常见问题]]。

*** Windows刻录

在Windows系统中有很多记录工具。

  - Easy Creator软件，选择文件，从CD映像刻录。修改文件类型为ISO映像，然后选择ISO文件并打开。点击开始后程序会把ISO映像正确的刻录到CD-R中。
  - Nero Burning ROM软件，取消自动弹出的向导，从文件菜单中选择刻录映像，选择映像并点击打开。然后点击刻录可以看到刻录过程。

*** Linux刻录

在Linux系统中，刻录ISO文件可以用[[http://packages.gentoo.org/package/app-cdr/cdrtools][app-cdr/cdrtools]]软件包中的 =cdrecord= 命令。

例如，刻录ISO文件到/dev/sr0设备（这是系统里的第一个CD设备，如果有需要请替换成正确的设备文件）：

#+BEGIN_SRC
user $ cdrecord dev=/dev/sr0 install--minimal-20141204.iso
#+END_SRC

用户可以选择[[http://packages.gentoo.org/package/app-cdr/k3b][app-cdr/k3b]]软件包中图形界面的刻录工具K3B，在K3B软件中，选择工具，刻录CD映像。然后根据接下来的提示进行操作。

* 启动CD

** 启动安装CD

如果已经刻录了CD，那么我们就可以由CD启动了。移除CD设备里的所有CD，重新启动系统进入BIOS或者UEFI。依照主板和所使用的系统一般是安 =DEL= ， =F1= 或者 =ESC= 进入。在BIOS或者UEFI的菜单里面，修改CD-ROM优先于硬盘启动。如果不这样修改，系统会忽略CD-ROM由硬盘启动。

#+BEGIN_QUOTE
*重要*

当安装Gentoo的目的是以使用UEFI接口替代BIOS时，建议立即由UEFI启动。如果不这么做，可能在安装完Gentoo Linux后，需要创建一个UEFI USB启动盘（或者其它媒介）。
/这段有问题/
#+END_QUOTE

现在把安装CD装入到CD-ROM里并启动。会出现一个启动提示符。在这个界面上，按 =Enter= 会以默认的选项启动系统。可以自定义启动选项，指定内核并输入 =Enter= 继续。

在启动提示符上，用户可以按显示可用内核（ =F1= ）和启动选项（ =F2= ）。如果15秒内没有选择（即没有选择内核，也没有显示信息），系统会从硬盘启动。这允许用户在不移除CD的情况下尝试他们已经安装的环境（试用于远程安装）。

我们提到的的指定内核。在安装CD上有好几种内核提供选择。默认的是gentoo。其它内核对于特殊的硬件需要用 /-nofb/ 的变种内核关闭帧缓存支持。

下面这个表格简短的列出了可用的内核。

| Kernel      | Description                                           |
|-------------+-------------------------------------------------------|
| gentoo      | 默认的内核，支持K8处理器（包含NUMA支持）和EM64T处理器 |
| gentoo-nofb | 和gentoo一样，但不支持帧缓冲                          |
| memtest86   | 测试本地RAM                                           |

和内核一起，启动选项有助于进一步优化引导过程。

|             | 硬件选项                                                                                                                                                                                                                            |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| acpi=on     | 这个选项加载ACPI，从CD启动时加载acpid服务。这只有在需要系统要求ACPI功能正常时使用，它不需要超线程支持。                                                                                                                           |
| acpi=off    | 宛全关闭ACPI。这对一些旧的硬件很有用并且是使用APM的必要条件。这也会关闭所有处理的所有超线程支持。                                                                                                                                   |
| console=X   | 这个选项是设置CD的串接设备访问，第一个选项是设备，在x86上一般是ttyS0，后面是用逗号分隔的连接选项。默认的选项是9600,8,n,1。                                                                                                          |
| dmraid=X    | 这个选项允许传递参数到RAID子系统。参数需要引号。                                                                                                                                                                                    |
| doapm       | 这个选项加载APM驱动，需要设置 =acpi=off= 。                                                                                                                                                                                         |
| dopcmcia    | 这个选项加载了PCMCIA和Cardbus硬件驱动，可以在CD启动的同时启动pcmia和cardmgr。这只在从PCMCIA/Cardbus设备启动时才需要。                                                                                                               |
| doscsi      | 这个选项支持多数的SCSI控制器。这也是启动USB设备的必要选项，因为它们使用了系统内核的SCSI子系统。                                                                                                                                     |
| sda=stroke  | 这个选项在BIOS不支持大存储器的时候，可以给整个硬盘分区。这个选项只在早期的BIOS系统中有用。在这个选项中把sda替换成需要的设备。                                                                                                       |
| ide=nodma   | 这个选项强制内核关闭DMA。并且需要一些IDE芯片组接口的CDROM驱动器，如果从IDE接口的CDROM读取信息有问题，可以试试这个选项，这同时关闭了hdparm的默认设备。                                                                               |
| noapic      | 这个选项禁用了目前只有较新的主板才有的高级可编程中断控制器，已经知道这个功能会导致一些旧设备出现问题。                                                                                                                              |
| nodetect    | 这个选项关闭了CD的自动检测功能，包括检测硬件和DHCP探测，这对调试有问题的CD或者驱动有用。                                                                                                                                            |
| nodhcp      | 这个选项关闭网卡的DHCP探测功能，这个在固定地址网络中很有用。                                                                                                                                                                        |
| nodmraid    | 这个选项关闭RAID设备映射支持，例如用于板载的IDE/SATA RAID控制器。                                                                                                                                                                   |
| nofirewire  | 这个选项关闭Firewire模块。如果在CD启动时你的Firewire引起了问题可以使用这个选项。                                                                                                                                                    |
| nogpm       | 这个选项关闭控制台gpm鼠标支持。                                                                                                                                                                                                     |
| nohotplug   | 这个选项关闭启动时热插拔和冷插拔初始化脚本。这对调试有问题的CD或驱动有用。                                                                                                                                                          |
| nokeymap    | 这个选项关闭非美国键盘的键位选择。                                                                                                                                                                                                  |
| nolapic     | 这个选项关闭单处理器内核上的APIC。                                                                                                                                                                                                  |
| nosata      | 这个选项关闭ATA系列模块。在SATA子系统出现问题时使用。                                                                                                                                                                               |
| nosmp       | 这个选项在打开SMP的内核上，关闭SMP或者对称式的多处理器功能，这对选定驱动和主板上调试SMP相关问题有用。                                                                                                                               |
| nosound     | 这个选项关闭声音支持和音量设置。对声音引起问题时有用。                                                                                                                                                                              |
| nousb       | 这个选项关闭USB模块自动加载。对调试USB问题有用。                                                                                                                                                                                    |
| slowusb     | 这在启动时为慢速USB、CDROM设备增加了一些额外的暂停，例如IBM BladeCenter。                                                                                                                                                           |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | 逻辑卷/设备管理                                                                                                                                                                                                                     |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| dolvm       | 这个选项支持Linux逻辑卷管理器。                                                                                                                                                                                                     |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | 其它选项                                                                                                                                                                                                                            |
|-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| debug       | 打开调试代码。这会导致屏幕输出一些凌乱的信息。                                                                                                                                                                                      |
| docache     | 这个选项会把CD完整的运行时环境加载到RAM中，允许用户卸载/mnt/cdrom并加载其它CDROM。这个选项要求内存最少要有CD的两倍大。                                                                                                              |
| doload=X    | 这个选项在ramdisk初始化时加载任何模块以及依赖关系，用模块名称替换X，多个模块名用逗号分隔。                                                                                                                                          |
| dosshd      | 这个选项在启动时开启sshd，这对远程安装有用。                                                                                                                                                                                        |
| passwd=foo  | 这个选项设置root密码，当root密码是默认时对dosshd必要.                                                                                                                                                                               |
| noload=X    | 这个选项让ramdisk初始化时跳过加载可能引起问题的指定模块，语法和doload一样。                                                                                                                                                         |
| nonfs       | 这个选项在启动时关闭portmap/nfsmount。                                                                                                                                                                                              |
| nox         | 这个选项让自动启动X环境的LiveCD不自动启动X，而是使用命令行。                                                                                                                                                                        |
| scandelay   | 这个选项在启动过程暂停10秒，让一些特定的部分允许硬件慢慢进行初始化以便使用。                                                                                                                                                            |
| scandelay=X | 这个选项允许用户设置一个延时.让一些特定的部分允许硬件慢慢进行初始化以便使用。用秒数替换X。 |

#+BEGIN_QUOTE
*备注*

CD会优先检查 =no*= 选项，再检查 =do*= 选项，所以可以重写指定选项的确切顺序。
#+END_QUOTE

现在启动CD，选择一个内核和启动选项（如果默认的 =gentoo= 内核不能满足）。例如，我们用 =Gentoo= 内核和 =dopcmicia= 选项：

#+BEGIN_SRC
boot: gentoo dopcmcia
#+END_SRC

接下来用户会见到启动界面和进度条。如果用户使用的是非美式键盘，要立即按 =Alt= + =F1= 切换到确认详细模式并且提示操作。如果在10秒钟内没有进行选择，系统会用默认（美式键盘）的键位设置继续安装。一旦启动完成，用户将以超级root身份登录到“LIVE”Gentoo Linux环境。控制台会显示root提示符，可以按 =Alt= + =F2= ， =Alt= + =F3= ， =Alt= + =F4= 切换控制台。按 =Alt= + =F1= 可以回到开始的控制台。

** 额外的硬件配置

当安装CD启动时，会尝试检测所有的硬件，然后加载合适的内存模块。在大多数情况下，会工作的很顺利。然而有些情况下可能不能正常加载系统所需的模块。如果PCI自动检测漏掉了一些系统硬件，必须要手动加载合适的内核模块。

下面的例子是加载8139模块（支持某些网络接口）：

#+BEGIN_SRC
root # modprobe 8139too
#+END_SRC

** 选项：用户账户

如果其它人要进入安装环境，或者在安装CD上需要用一个普通帐户执行命令（例如用 =irssi= 聊天而为了安全原因不用root权限），那么需要新建一个用户并给root用户设置一个密码。

更改密码，用passwd程序：

#+BEGIN_SRC
root # passwd
New password: (Enter your new password)
Re-enter password: (Re-enter your password)
#+END_SRC

新建一个用户账户，首先输入权限，随后输入帐户密码。用 =useradd= 和 =passwd= 命令操作。

下面的例子，创建一个叫 /john/ 的用户：

#+BEGIN_SRC
root # useradd -m -G users john
root # passwd john
New password: (Enter john's password)
Re-enter password: (Re-enter john's password)
#+END_SRC

从root帐户（当前帐户）切换到新建账户，用 =su= 命令：

#+BEGIN_SRC
root # su - john
#+END_SRC

** 选项：在安装时查看文档

在安装的时候查看Gentoo手册，首先像上面说的那样创建一个账户。然后按 =Alt= + =F2= 切换到一个新的终端。

在安装的过程中， =links= 使用可以用来查看Gentoo手册——当然只有在网络正常工作时可用。

#+BEGIN_SRC
user $ links https://wiki.gentoo.org/wiki/Handbook:AMD64
#+END_SRC

按 =Alt= + =F1= 回到原来的终端。

** 选项：启动SSH服务

如果想在安装的过程中允许其它用户进入系统（也许是帮助安装，甚至是运程安装），需要创建一个新的帐户（见上面的文档）并且开启SSH服务。

用如下命令启动SSH服务：

#+BEGIN_SRC
root # /etc/init.d/sshd start
#+END_SRC

#+BEGIN_QUOTE
*备注*

如果用户登录到系统，他们会得到一个主机密钥（指纹）。主机密钥标识第一次登录到系统的用户。然而，稍后当系统安装完成时，有人登录到新的系统，SSH客户端为警告主机密钥已经被更改，这是因为用户已经登录了一个不同的服务器（即新的已安装的Gentoo系统而不是用于安装的Live环境），按照提示信息在客户端上替换主机密钥。
#+END_QUOTE

为了能够使用sshd，网络功能必须正常。可以继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Networking][网络配置]]。

* 自动检测网络

已经可以工作了？

如果系统已经加入到一个带有DHCP服务的以太网，网络很可能已经自动设置好了。如果是这样，那么在安装CD上许多网络命令是可以使用的，像 =ssh= 、 =scp= 、 =ping= 、 =irrssi= 、 =wget= 和 =links= 可以以立即工作。

如果网络已经成功设置， =ifconfig= 命令可以列出除 =lo= 以外的一些网络接口，例如 =eth0= ：

#+BEGIN_SRC
root # ifconfig

(...)
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11 Base address:0xe800
#+END_SRC

在系统上显示的接口名可能不同于 =eth0= 。最近安装的介质可能显示正正式的网络接口名称，像 =eno0= 、 =ens1= 或者 =enp5s0= 。你可以找到和本地网络IP地址相关的网络接口名。

在接下来的文档中，我们假设接口名为 =eth0= 。

** 选项：设置代理

如果想通过代理连接网络，那么需要在安装的时候设置一下代理，非常简单：只需要定义一个包含代理服务信息的变量就可以。

大多数情况下，定义一个服务器主机名的变量就可以了。例如，我们假设代理地址是proxy.gentoo.org端口是8080。

设置一个HTTP代理（HTTP和HTTPS协议）：

#+BEGIN_SRC
root # export http_proxy="http://proxy.gentoo.org:8080"
#+END_SRC

设置一个FTP代理：

#+BEGIN_SRC
root # export ftp_proxy="ftp://proxy.gentoo.org:8080"
#+END_SRC

设置一个RSYNC代理：

#+BEGIN_SRC
root #export RSYNC_PROXY="proxy.gentoo.org:8080"
#+END_SRC

如果代理需要用户名和密码，用下面的语法设置这个变量：

#+BEGIN_SRC
*代码* 在代理变量中加入用户名和密码

http://username:password@proxy.gentoo.org:8080
#+END_SRC

** 测试网络

尝试去侦测你网络提供商的DNS服务器（在/etc/resolv.conf中找到）和某个网站。这用来确认网络功能正常，网络数据包传输正常，DNS解析服务正常等。

#+BEGIN_SRC
root # ping -c 3 www.gentoo.org
#+END_SRC

如果一切顺利，可以跳过本章节的余下部分，直到下一步安装指令（磁盘准备）。

* 自动设置网络

如果网络不能立即工作，一些安装介质允许用户使用 =net-setup= （普通和无线网络）、 =pppoe-setup= （ADSL用户）或者 =pptp= （PPTP用户）。

如果安装介质不包括这些工具，请参看[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Manual_network_configuration][手动网络设置]]。

  - 普通的以太网用户需要用[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Default:_Using_net-setup][默认：使用net-setup]]
  - ADSL用户需要用[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Alternative:_Using_PPP][可选：使用PPP]]
  - PPTP用户需要用[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Alternative:_Using_PPTP][可选：使用PPTP]]

** 默认：使用net-setup

如果网络没有自动配置，那么用如下的 =net-setup= 脚本是配置网络最简单的方法：

#+BEGIN_SRC
root # net-setup eth0
#+END_SRC

=net-setup= 会问题一些网络环境的问题。当设置完成后网络应该可以正常工作了。用上面提到的方法测试网络。如果测试成功，那么恭喜你！跳过下面的一段直接阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks][磁盘准备]]。

如果网络依然不能工作，继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Manual_network_configuration][手动设置网络]]。

** 可选：使用PPP

如果连接网络需要PPPoE，安装CD（所有版本）简化PPP的设置。使用 =pppoe-setup= 脚本设置连接。在设置以太网设备连接到ADSL网络适配器时，需要填写用户名、密码、DNS服务的IP和基本的防火墙设置。

#+BEGIN_SRC
root # pppoe-setup
root # pppoe-start
#+END_SRC

如果出现了错误，请仔细检查etc/ppp/pap-secrets或者/etc/ppp/chap-secrets文件中的用户名和密码，并确保使用正确的以太网设备。如果没有以太网设备，需要加载合适的网络模块。这种情况下请阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Manual_network_configuration][手动设置网络]]，那里会详细解释怎么加载合适的网络模块。

如果一切正常，继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks][磁盘准备]]。

** 可选：使用PPTP

如果需要PPTP支持，使用安装CD中的 =pptpclient= 。但是首先确认网络配置正确。编辑/etc/ppp/pap-secrets或者/etc/ppp/chap-secrets，这里包含了正确的用户名和密码。

#+BEGIN_SRC
root # nano -w /etc/ppp/chap-secrets
#+END_SRC

如果需要的话调整一下/etc/ppp/options.pptp：

#+BEGIN_SRC
root # nano -w /etc/ppp/options.pptp
#+END_SRC

当一切都完成，运行 =pptp= （后面的选项不能在options.pptp里设置） 连接服务器：

#+BEGIN_SRC
root # pptp <server ip>
#+END_SRC

现在继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks][磁盘准备]]。

* 手动设置网络

** 加载合适的网络模块

当安装CD启动时，会尝试检测所有的硬件并加载相应的模块（驱动）。大多数情况下可以正常工作。然而，有时候也不能自动加载一些模块。

如果 =net-setup= 或者 =pppoe-setup= 设置失败，很可能没有检测到网卡。这意味着用户可能需要手动加载合适的内核模块。

用 =ls= 查看为网络提供的内核模块：

#+BEGIN_SRC
root # ls /lib/modules/`uname -r`/kernel/drivers/net
#+END_SRC

如果找到了适合网络设备的驱动程序，用 =modprobe= 去加载这个模块。例如，加载 =pcnet32= 模块：

#+BEGIN_SRC
root # modprobe pcnet32
#+END_SRC

查看是否检测到网卡，使用 =ifconfig= 。检测到的网卡的结果大概是下面这个样子（再说一次，eth0只是一个例子）：

#+BEGIN_SRC
root # ifconfig eth0

eth0      Link encap:Ethernet  HWaddr FE:FD:00:00:00:00
          BROADCAST NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
#+END_SRC

如果显示下这个错误，说明还是没有检测到网卡：

#+BEGIN_SRC
root # ifconfig eth0
eth0: error fetching interface information: Device not found
#+END_SRC

可以通过/sys文件查看有效的网络接口名：

#+BEGIN_SRC
root #ls /sys/class/net
dummy0  eth0  lo  sit0  tap0  wlan0
#+END_SRC

在上面这个例子，找到了6个接口。eth0比较像（有线）以太网适配器，wlan0是无线网络适配器。

假设已经检测到了网卡，再试一次 =net-setup= 或者 =pppoe-setup= （现在可以工作了），对于顶级用户我们解释怎么更好的手动配置网络。

根据你的网络选择一个章节：

  - [[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Using_DHCP][使用DHCP]] 获取IP地址
  - [[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Preparing_for_wireless_access][准备无线设置]] 如果用无线网络
  - [[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Understanding_network_terminology][了解网络术语]] 讲解基本的网络知识
  - [[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Using_ifconfig_and_route][使用ifconfig和route]] 说明怎么手动设置网络

** 使用DHCP

DHCP（动态主机设置协议）会自动获取网络信息（IP地址、子网掩码、广播地址、网关和域名服务器等）。只有当网络中有DHCP服务器（或者ISP提供DHCP服务）时才可以正确工作。用 =dhcpcd= 命令自动获取这些信息：

#+BEGIN_SRC
root # dhcpcd eth0
#+END_SRC

一些网络管理员需要知道DHCP服务的主机名和域名。这种情况可以使用：

#+BEGIN_SRC
root # dhcpcd -HD eth0
#+END_SRC

** 准备无线网络

#+BEGIN_QUOTE
*备注*

=iwconfig= 命令可能和体系结构有关。如果找不到这个命令，请参考[[ftp://ftp.linux-wlan.org/pub/linux-wlan-ng/README][linux-wlan-ng]]项目。
#+END_QUOTE

当使用无线网卡（802.11），在进一步设置之前要配置无线设置。可以使用 =iwconfig= 想查看当前的无线链接设置。执行 =iwconfig= 可能会显示如下信息：

#+BEGIN_SRC
root # iwconfig eth0
eth0      IEEE 802.11-DS  ESSID:"GentooNode"
          Mode:Managed  Frequency:2.442GHz  Access Point: 00:09:5B:11:CC:F2
          Bit Rate:11Mb/s   Tx-Power=20 dBm   Sensitivity=0/65535
          Retry limit:16   RTS thr:off   Fragment thr:off
          Power Management:off
          Link Quality:25/10  Signal level:-51 dBm  Noise level:-102 dBm
          Rx invalid nwid:5901 Rx invalid crypt:0 Rx invalid frag:0 Tx
          excessive retries:237 Invalid misc:350282 Missed beacon:84
#+END_SRC

#+BEGIN_QUOTE
*备注*

一些无线网卡可能不是eth0而是wlan0或者ra0。不带任何参数执行 =iwconfig= 可以找到正确的设备名称。
#+END_QUOTE

对于大多数用户，有两个重要的地址需要修改，ESSID（即无线网络名称）或者WEP密钥。如果已经列出的的ESSID和接入点不需要使用WEP，那么无线设置已经可以正常工作。

修改ESSID或者增加WEP密钥，发出如下命令。

  - 设置网络名称为GentooNode：

#+BEGIN_SRC
root # iwconfig eth0 essid GentooNode
#+END_SRC

  - 设置16进制WEP密钥：

#+BEGIN_SRC
root # iwconfig eth0 key 1234123412341234abcd
#+END_SRC

设置ASCII格式的WEP密钥，在密钥前加 =s:= ：

#+BEGIN_SRC
root # iwconfig eth0 key s:some-password
#+END_SRC

如果无线网络设置为WPA或者WPA2，那么可能需要使用 =wpa_supplicant= 。请查看[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Networking/Wireless][Gentoo手册中无线网络章节]]获取更多无线网络设置的帮助信息。

用 =iwconfig= 再次确认无线网络设置。如果无线网线已经工作，继续按照下一节的说明（[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Understanding_network_terminology][了解网络术语]]）或者使用前面所描述的 =net-setup= 配置IP级别的网络选项。

** 了解网络术语

#+BEGIN_QUOTE
*备注*

如果知道IP地址、广播地址、子网掩码和域名服务器，那个跳过这个小节继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Using_ifconfig_and_route][使用ipconfig和route]]。
#+END_QUOTE

如果上面所说的都无效，那么需要手动配置网络。这一步不是很难。但是，需要知道一些网络术语和基础知识。读完这节后，用户用户将会了解网关是什么，子网掩码是干什么的，广播地址是怎么形成的和为什么系统需要一个域名服务器。

在一个网络里，用IP（互联网协议地址）标识一个主机。这样的地址可以看做是由4个0到255的数字组成。到少在IPv4（IP第4个版本）是这样。在现实中，这样的IPv4地址由32个比特位（0或者1）组成。我们看一个例子：

#+BEGIN_SRC
*代码* IPv4地址示例

IP Address (numbers):   192.168.0.2
IP Address (bits):      11000000 10101000 00000000 00000010
                        -------- -------- -------- --------
                           192      168       0        2
#+END_SRC

#+BEGIN_QUOTE
*备注*

IPv4的继任者IPv6，使用128个比特位（0或者1）。在这一节当中，我个只讨论IPv4地址。
#+END_QUOTE

对所访问的网络而言，每台主机的IP地址都是独一无二的（即每个主机都有自已的IP地址）。为了区分主机内部网络还是外部网络，IP地址分成两个部分：网络部分和主机部分。

分离方法用子网掩码记录，子网掩码包含着1的集合后接着0的集合。网络部分可以用1集合映射得出，另一个部分就是主机部分。一般子网掩码写成IP的格式。

#+BEGIN_SRC
*代码* 网络和主机区分示例

IP address:    192      168      0         2
            11000000 10101000 00000000 00000010
Netmask:    11111111 11111111 11111111 00000000
               255      255     255        0
           +--------------------------+--------+
                    Network              Host
#+END_SRC

也就是说，192.168.0.14在这个示例网络的一部分，但是192.168.1.2不是。

广播地址是一个拥有同样网络部分的的IP，只是拥有唯一的一个IP。第个主机都会监听这个IP。他真正的用途是广播数据包。

#+BEGIN_SRC
*代码* 广播地址

IP address:    192      168      0         2
            11000000 10101000 00000000 00000010
Broadcast:  11000000 10101000 00000000 11111111
               192      168      0        255
           +--------------------------+--------+
                     Network             Host
#+END_SRC

想要上网，在网络中的每个计算都要知道哪个主机共享了网络连接。这个主机叫做网关。由于它是一个普通主机，它也有一个常规的IP（例如192.168.0.1）。

前面说每台主机都要有一个自已的IP。要想用一个名字连接这个主机，我们需要一个可以把名字（例如dev.gentoo.org）翻译成IP（64.5.62.82）的服务。我们需要在/etc/resolv.conf定义这个服务。

有些情况下，网关也提供域名解析服务。否则ISP提供的域名需要写在这个文件中。

总结，在继续前下面的信息是必要的：

| Network Item          |                        Example |
|-----------------------+--------------------------------|
| The system IP address |                    192.168.0.2 |
| Netmask               |                  255.255.255.0 |
| Broadcast             |                  192.168.0.255 |
| Gateway               |                    192.168.0.1 |
| Nameserver(s)         | 195.130.130.5, 195.130.130.133 |

** 使用ifconfig和route

设置网络有以下三步：

  1. 用 =ifconfig= 填写IP地址
  2. 用 =route= 设置网关路由
  3. 在/etc/resolv.conf填写域名解析

填写IP时，需要同时填写IP地址、广播地址、子网掩码。用有效的IP替换 =${IP_ADDR}= 、广播地址替换 =${BROADCAST}= 、 网关替换 =${NETMASK}= 执行下面的命令：

#+BEGIN_SRC
root # ifconfig eth0 ${IP_ADDR} broadcast ${BROADCAST} netmask ${NETMASK} up
#+END_SRC

用 =route= 设置路由。用有效的网关替换 =${GATEWAY}= ：

#+BEGIN_SRC
root # route add default gw ${GATEWAY}
#+END_SRC

现在打开/etc/resolv.conf文件：

#+BEGIN_SRC
root # nano -w /etc/resolv.conf
#+END_SRC

模仿下面的模板填写域名解析。确定使用有有效的域名解析地址替换 =${NAMESERVER1}= 和 =${NAMESERVER2}= ：

#+BEGIN_SRC
*代码* /etc/resolv.conf文件默认的模板

nameserver ${NAMESERVER1}
nameserver ${NAMESERVER2}
#+END_SRC

现然测试并侦测一些互联网服务（例如Google）。如果可以正常工作，那么设置完成。继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks][磁盘准备。]]

* 块设备简介

** 块设备

让我们看一看Gentoo Linux磁盘方面的问题，包括文件系统、分区和块设备。一旦理解了文件系统的来龙去脉，我们就会为Gentoo Linux设置分区和文件系统。

开始，我们先看看块设备。最知名的块设备可能是Linux系统的第一个驱动器/dev/sda。SCSI和串口ATA都标记为/dev/sd*；在新的内核的libata架构下IDE设备也被标记为/dev/sd*。如果用老的硬件架构，第一个IDE设备是/dev/hda。

上面介绍的块设备代表磁盘的抽象接口。用户可以使用块设备编写读写磁盘的程序，不需要关注是使用的IDE、SCSI或者其它的什么设备。程序可以简单的以连续的数据或者随机的512字节来定位存储数据。

** 分区

尽管理论上可以使用整个磁盘来存储Linux系统，但在实际上几乎从不这样做。我们经常把磁盘分成较小的可以更方便管理的块设备。在AMD64系统上，这个操作叫做分区。有两个标准的分区技术可以使用：MBR和GPT。

*** MBR

MBR（主引导记录）用32位标识符表示起始扇区和分区长度，支持3种分区类型：主分区，扩展分区和逻辑分区。主分区把信息存储在自已的MBR中——在磁盘开始位置的一个很小的区域（通常是512字节）。因为这个空间很小，所以只支持4个主分区（例如/dev/sda1到/dev/sda4）。

要想支持更多分区，其中一个主分区可以标记为扩展分区。这个分区可以包含一些逻辑分区（分区中的分区）。

第个分区被限制为2TB之内（因为32位标识符）。MBR不提供备份机制，所以如果有应用破坏了MBR，所有的分区信息都会丢失。

*** GPT

GPT（全局唯一标识分区表）使用64位标识符标识分区，其中存储分区信息的位置也要比512字节的MBR大的多，也没有限制分区的数量。同时，分区也可以更大（大概8ZB）。

当使用UEFI（替换BIOS）和操作系统进行交互时，几乎必须使用GPT，因为MBR有一些兼容性问题。

GPT有更先进的功能，它可以在磁盘末尾备份分区表，它可以覆盖磁盘开头已损坏的GPT信息。GPT使用CRC32校验来检测分区表错误。

** GPT还是MBR

在上面的说明中，有人可能会想更建议使用GPT。但是还有一警告。

在运行BIOS系统的计算机上使用GPT，不能实现Windows双系统启动。因为检测到GPT分区表后Windows会以EFI模式启动。

当一些有缺陷的BIOS或者EFI，配置以BIOS/CSM/传统模式启动时，可能会在GPT分区磁盘上产生问题。如果这样的话，可以通过 =fdisk= 和 =-t dos= 强制用MBR格式读这个分区表，并在这个分区表上设置boot/active标记解决这个问题。

这种情况下，启动 =fdisk= 在第一个分区（ =1= ）用 =a= 切换标记。用 =w= 保存修改并退出 =fdisk= ：

#+BEGIN_SRC
user $ fdisk -t dos /dev/sda
Welcome to fdisk (util-linux 2.24.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): a
Partition number (1-4): 1

Command (m for help): w
#+END_SRC

** 使用UEFI

当使用UEFI（替代BIOS）启动操作系统来安装Gentoo，创建一个EFI系统分区是很重要的。接下来的指令是要点。

EFI系统分区需要分区为FAT32格式（或者在Linux系统上显示为vfat的格式）。这节的末尾使用ext2文件系统的例子创建boot分区。用下面的方法确定使用vfat格式：

#+BEGIN_SRC
root # mkfs.vfat /dev/sda2
#+END_SRC

#+BEGIN_QUOTE
*警告*

如果boot分区不使用FAT32（vfat）文件系统，那么UEFI固件将找不到Linux内核，造成不能启动！
#+END_QUOTE

** 高级存储

AMD64安装CD支持LVM2。LVM2增加了系统分区的灵活性。在安装的过程中，我们关注“常规”分区，但是了解LVM2也是很有用的。

*** 默认的分区方案

我们使用下面的分区方案贯穿整个手册的剩余部分。如果这个方案足够用户使用，可以跳到[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Default:_Using_parted_to_partition_the_disk][默认：使用parted进行磁盘分区]]或者[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Alternative:_Using_fdisk_to_partition_the_disk][可选：使用fdisk进行磁盘分区。两个都是磁盘分区工具，]] =fdisk= 是知名且稳定分区工具，建议在MBR分区上使用。 =parted= 是刚出现的分区工具，建议在GPT分区使用。

| Partition | Filesystem     | Size             | Description         |
|-----------+----------------+------------------+---------------------|
| /dev/sda1 | (bootloader)   | 2M               | BIOS boot partition |
| /dev/sda2 | ext2 (or vfat) | 128M             | Boot partition      |
| /dev/sda3 | (swap)         | 512M or higher   | Swap partition      |
| /dev/sda4 | ext4           | Rest of the disk | Root partition      |

在执行创建分区命令前，第一组章节会介绍更多关于分区方案和相关的问题。

* 设计一个分区方案

** 多少和多大

分区的数量依赖于使用环境，例如，如果有很多用户，那么建议设置 ~/home/~ 分区增加安全性并且容易备份。如果把Gentoo当做邮件服务器使用，那么应该设置 ~/var/~ 分区来保存所有的邮件。然后文件系统的选择将会提高系统性能。游戏服务器需要把游戏服务安装到 ~/opt/~ 分区中。和 ~/home/~ 分区的原因一样：安全并且容易备份。大多数情况下， ~/usr/~ 分区要大点：它不只是包含主要的应用程序，还包括了大概500M的Portage树文件，而且还没算各种数据源。

像我们看到的，分区依赖于管理员的目标。分区的建议如下：

  - 每个分区或卷选择性能最好的文件系统
  - 如果一个废弃的工具连续向分区或者卷写入数据，系统不会耗尽其它分区的剩余空间
  - 如果需要，可以减少文件系统检查，多个文件检查可以并行（虽然这个功能在多磁盘比多分区效果更好）
  - 挂在只读分区或者卷可以提升安全性， =nosuid= （忽略setuid特性）， =noexec= （忽略执行特性）等

虽然，多分区也有缺点。如果配置不当，系统可能在某个分区空间耗尽时，另一个分区却有很多剩余空间，另一个问题是——特别是比较重要的挂在点 ~/usr/~ 或者 ~/var/~ ——管理员经常需要在其它启动脚本开始前，先用已经初始化的文件系统挂在分区。虽然不总是这样，但是结果可能有所不同。

除非使用GPT标签，否则SCSI和SATA最多只能有15个分区。

** 交换空间

交换空间没有完美的大小。交换空间的目的是当内存用尽的时候，保存内核中的数据。交换空间允许内核将不需要马上使用的内存页存储到磁盘上，从而释放内存。当然，如果突然需要这段内存，这些用一些时间把内存页会重新读回内存（磁盘比内存要慢的多）。

当系统不使用内存密集型应用，或者系统有很多内存，那么基本不需要很大的交换空间。然而，交换空间还用于在休眠情况下存储整个内存。如果系统需要休眠，那么需要大点的交换空间，通常最小的交换空间也得和系统内存一样大。

** 什么是BIOS启动分区

BIOS启动分区是一个很小的分区（1MB到2MB），它保存GRUB2的一些附加数据，这些数据分配空间（MBR标签的情况下有几百个字节）也不能放到其它位置。

考虑到低空间消耗或者需要记录的分区差异过多，我们不需要BIOS分区。其它情况下我们建议创建这个分区。

为了完整起见，当我们使用GPT标签和GRUB2时，需要创建BIOS分区，或者在使用MBR标签和GRUB2，第一个分区开始的位置在磁盘开始处1MB时，我们也需要BIOS分区。

* 默认：使用parted进行磁盘分区

在这一章，我们会使用前面提到的分区布局：

| Partition | Description         |
|-----------+---------------------|
| /dev/sda1 | BIOS boot partition |
| /dev/sda2 | Boot partition      |
| /dev/sda3 | Swap partition      |
| /dev/sda4 | Root partition      |

用户可以根据偏好修改自己的分区表。

** 用parted查看当前的分区表

=parted= 程序为分区提供了一个简单的接口，并且支持大分区（大于2TB）。在磁盘上启动 =parted= （在我们的例子中，使用 /dev/sda）。建议使用 =parted= 进行最优的磁盘分区对齐：

#+BEGIN_SRC
root # parted -a optimal /dev/sda
GNU Parted 2.3
Using /dev/sda
Welcome to GNU Parted! Type 'help' to view a list of commands.
#+END_SRC

对齐就是说磁盘上的分区开始于一个知名的位置，以确保磁盘操作，使用系统级操作（获取磁盘页面），这会尽量的少的使用内置磁盘操作。当系统要求获取一个页面时，没对齐的分区可能会要求磁盘获取两个页面，即使系统只要求一个。

输入 =help= 并按回车，查看parted的所有选项。

** 设置GPT标签

许多x86/amd64上的磁盘默认的是msdos标签。使用 =parted= ，设置GPT标签的命令是 =mklabel gpt= 。

#+BEGIN_QUOTE
*警告*

修改分区类型会删除磁盘上的所有分区。磁盘里的所有数据将会丢失。

#+BEGIN_SRC
(parted) mklabel gpt
#+END_SRC

使用 =mklabel msdos= 设置MBR标签。

** 用parted删除所有分区

如果还没有完事儿（例如刚刚 =mklabel= 操作，或者因为磁盘是刚格式化过的），首先从磁盘删除所有分区。输入 =print= 查看当前分区，再输入 =rm NUMBER= 删除分区。

#+BEGIN_SRC
(parted) rm 2
#+END_SRC

不需要所有的分区都这么操作，不管怎么样，一定要确认不要犯任何错误——parted会立即执行修改（不像 =fdisk= 那样，在保存之前允许用户撤销修改或者退出）。

** 创建分区

现在创建分区。用 =parted= 创建分区很简单——我们需要做的就是通知 =parted= 如下设置：

  - 使用的分区类型。这个通常很重要。如果使用msdos分区标签，请记住最多只能有4个主分区。如果需要超过4个分区，把4个分区中的第一个分区改为扩展分区，并在扩展分区中建立逻辑分区
  - 分区开始位置（可以用MB，GB，等表示）
  - 分区结束位置（可以用MB，GB，等表示）

首先，告诉parted我们使用Megabytes单位（实际上是mebibytes，标准上缩写为MiB符号，但是在文本中我们使用更通用的MB）：

#+BEGIN_SRC
(parted) unit mib
#+END_SRC

现在创建一个2MB的分区一会儿用于GRUB2启动器。用 =mkpart= 命令通知 =mkpart= 开始于1MB并结束于3 MB（创建一个2 MB的分区）。

#+BEGIN_SRC
(parted) mkpart primary 1 3
(parted) name 1 grub
(parted) set 1 bios_grub on
(parted) print

Model: Virtio Block Device (virtblk)
Disk /dev/sda: 20480MiB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number   Start      End      Size     File system  Name   Flags
 1       1.00MiB    3.00MiB  2.00MiB               grub   bios_grub
#+END_SRC

用同样的方法创建boot分区（128 MB），交换分区（在例子中，512 MB），和用剩下的空间建立root分区（结束位置用-1标记，意思是磁盘末尾减1MB，这是最大分区的建立方法）。

#+BEGIN_SRC
(parted) mkpart primary 3 131
(parted) name 2 boot
(parted) mkpart primary 131 643
(parted) name 3 swap
(parted) mkpart primary 643 -1
(parted) name 4 rootfs
#+END_SRC

当使用UEFI接口来启动系统（替代BIOS），标记boot分区为EFI系统分区。当启动选项设置在分区上parted会自动这样设置。

#+BEGIN_SRC
(parted) set 2 boot on
#+END_SRC

最后的结果像下面这样：

#+BEGIN_SRC
(parted) print
Model: Virtio Block Device (virtblk)
Disk /dev/sda: 20480MiB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number   Start      End      Size     File system  Name   Flags
 1       1.00MiB    3.00MiB  2.00MiB               grub   bios_grub
 2       3.00MiB    131MiB   128MiB                boot
 3       131MiB     643MiB   512MiB                swap
 4       643MiB     20479MiB 19836MiB              rootfs
#+END_SRC

#+BEGIN_QUOTE
*备注*

在UEFI接口下安装，启动标识会在boot分区上显示。
#+END_QUOTE

使用 =quit= 退出parted。

* 可选：使用fdisk进行磁盘分区

#+BEGIN_QUOTE
*备注*

虽然近期的fdisk版本可以支持GPT，但是还有一些问题。下面的安装命令假设用户使用的MBR分区表。
#+END_QUOTE

下面这部分会解释怎么用 =fdisk= 进行示例分区。前面提到的样例分区表如下：

| Partition | Description  |
|-----------+--------------|
| /dev/sda1 | BIOS启动分区 |
| /dev/sda2 | 启动分区     |
| /dev/sda3 | 交换分区     |
| /dev/sda4 | 主分区       |

用户可以根据偏好修改分区表。

** 查看当前分区表

=fdisk= 是一个很流行的磁盘分区软件。对磁盘启动 =fdisk= （在我们的示例中使用/dev/sda）：

#+BEGIN_SRC
root # fdisk /dev/sda
#+END_SRC

#+BEGIN_QUOTE
*备注*

使用 =-t gpt= 来支持GPT。建议密切关注fdisk的输出，以防止fdisk近期的发展改变了默认为MBR的情况。余下的章节假设使用MBR表。
#+END_QUOTE

输入 =p= 来查看当前的分区配置：

#+BEGIN_SRC
Command (m for help): p
Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/sda1   *         1        14    105808+  83  Linux
/dev/sda2            15        49    264600   82  Linux swap
/dev/sda3            50        70    158760   83  Linux
/dev/sda4            71      2184  15981840    5  Extended
/dev/sda5            71       209   1050808+  83  Linux
/dev/sda6           210       348   1050808+  83  Linux
/dev/sda7           349       626   2101648+  83  Linux
/dev/sda8           627       904   2101648+  83  Linux
/dev/sda9           905      2184   9676768+  83  Linux
#+END_SRC

这个磁盘配置安装了7个Linux文件系统（每个分区都用“linux”标识）以及一个交换分区（用“Linux swap”标识）。

** 用fdisk删除所有分区

首先删除磁盘所有的分区。输入 =d= 删除分区。例如，删除/dev/sda1：

#+BEGIN_SRC
Command (m for help): d
Partition number (1-4): 1
#+END_SRC

分区已经设置为计划删除。输出分区列表时不会显示这个分区（ =p= ）, 直到保存修改前，它的数据不会被擦除。这允许用户输入错的情况下终止操作——输入错了的话，输入 =q= 并按回车不保存修改立即退出程序。

重按 =p= 输出分区列表，输入 =d= 和分区序号来删除分区。直到分区列表为空：

#+BEGIN_SRC
Command (m for help): p
Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
#+END_SRC

现在内存中的分区列表为空，我们准备新建分区。

** 新建BIOS启动分区

首先新建一个小的BIOS启动分区。输入 =n= 新建分区，输入 =p= 选择主分区，输入 =1= 表示建立第一个主分区。当提示第一个扇区，确定他开始于2048（boot loader指定）按回车。当提输入最后一个扇区，输入+2M新建一个2 Mb的分区：

#+BEGIN_QUOTE
*备注*

在启动引导器不能正确检查这是个分区时，从2048扇区开始是不够安全。
#+END_QUOTE

#+BEGIN_SRC
Command (m for help): n
Command action
  e   extended
  p   primary partition (1-4)
p
Partition number (1-4): 1
First sector (64-10486533532, default 64): 2048
Last sector, +sectors +size{M,K,G} (4096-10486533532, default 10486533532): +2M
#+END_SRC

标记分区为EFI系统：

#+BEGIN_SRC
Command (m for help): t
Selected partition 1
Hex code (type L to list codes): ef
Changed system type of partition 1 to ef (EFI (FAT-12/16/32))
#+END_SRC

#+BEGIN_QUOTE
*备注*

不鼓励EFI系统和MBR分区一起使用。如果使用有EFI功能的系统，请使用GPT表。
#+END_QUOTE

** 创建启动分区

现在创建一个小的启动分区。输入 =n= 新建分区，输入 =p= 选择主分区，输入 =2= 建立第二个主分区。当提示输入首扇区，按 =Enter= 默认。当提示输入最后一个扇区，输入+128M建立一个128MB的分区：

#+BEGIN_SRC
Command (m for help): n
Command action
  e   extended
  p   primary partition (1-4)
p
Partition number (1-4): 2
First sector (5198-10486533532, default 5198): (Hit enter)
Last sector, +sectors +size{M,K,G} (4096-10486533532, default 10486533532): +128M
#+END_SRC

现在输入 =p= 输出如下：

输入 =a= 选择 =2= 切换可启动标记，再次输入 =p= ，请注意“Boot”列中多了一个*号。

** 创建交换分区

要想创建交换分区，先输入 =n= 新建一个分区，然后输入 =p= 让fdisk知道这是个主分区。输入 =3= 建立第三个主分区/dev/sda3。当提示输入首扇区时，按 =Enter= 默认。当提示输入最后一个扇区，输入+512M（或者所需的交换分区大小）建立一个512MB的分区。

完成后，输入 =t= 设置分区类型， 输入 =3= 选择刚刚建立的分区，输入 /82/ 选择“Linux Swap”类型。

** 创建主分区

最后创建主分区，输入 =n= 新建一个分区， 输入 =p= 选择主分区，输入 =4= 建立第四个主分区/dev/sda4。当提示输入首扇区，按回车默认。当提示入尾扇区，按回车使用磁盘剩余空间。完成后输入 =p= 可以显示分区列表：

#+BEGIN_SRC
Command (m for help): p
Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1         3      5198+  ef  EFI (FAT-12/16/32)
/dev/sda2   *         3        14    105808+  83  Linux
/dev/sda3            15        81    506520   82  Linux swap
/dev/sda4            82      3876  28690200   83  Linux
#+END_SRC

** 保存分区表

输入 =w= 保存并退出 =fdisk= 。

#+BEGIN_SRC
Command (m for help): w
#+END_SRC

创建完分区后，该是建立文件系统的时候了。

* 建立文件系统

** 简介

现在已经创建了分区，应该设置一个文件系统。在下面一节中介绍了多种Linux支持的文件系统。如用户已经知道要使用哪种文件系统，可以跳到[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Applying_a_filesystem_to_a_partition][分区使用文件系统继续阅读。其它用户需要先了解一些文件系统知识。]]

** 文件系统

有好多种文件系统可以选择。有一些文件系统在amd64架构下表现比较稳定——在重要的分区使用文件系统前，请仔细研究文件系统知识。

*ext2*

  这个文件系统可以成为正式的Linux文件系统，但是它没有元数据日志，这意味着ext2文件系统启动时非常耗时。现在已经有很多新一代的日志文件系统可以这种非日志的系统。这种系统可以快速检查一致性，防止在文件系统启动发现不一致时出现较长时间的延迟。

*ext3*

  ext2文件系统的日志功能版本，除子提供可以快速恢复的元数据日志功能外，还提升了例如完整数据和指令数据的日志模式。它使用HTree索引可以在基本所有状态表现优异。简而言之，ext3是一个可靠的文件系统。

*ext4*

  作为ext3的分支版本，ext4有很多新的功能，提升了性能并适当的移除了大小限制。可以让卷的大小达到1EB，文件大小达到16TB。用extents替代了ext2/ext3经典的bitmap块分配方式，这种方式可以提升大文件的读写性能并减少磁盘碎片。Ext4提供了复杂的块分配算法（延迟分配和多块分配），可以让文件系统驱动用很多法调优数据表现。推荐所有通用平台都使用Ext4文件系统。

*JFS*

  IBM的高性能日志文件系统。JFS是基于B+树的一个轻量级、快速并且可信赖的文件系统，它可以在很多情况下表现良好。

*ReiserFS*

  基于B+树的日志文件系统，总体性能不错，特别是处理消耗CPU时间的很多小文件时。ReiserFS照比其它文件系统更容易维护。

*XFS*

  一个有元数据日志功能的文件系统，它有更健壮的功能可以对scalability优化。XFS看上去不能很好的处理各种硬件问题。

*vfat*

  也被称为FAT32，Linux支持这种文件系统，但是它不支持权限设置。它经常用于其它操作系统（主要是Microsoft Windows），但也是一些固件系统（比如UEFI）所必须的文件系统。


如果在小分区（小于8GB）上使用ext2，ext3或者ext4文件系统时，那么需要用合适的参数创建文件系统来保留足够的索引节点。 =mke2fs= 应用使用“多少字节一个索引节点”来计算文件系统需要多少索引节点。在较小的分区上，建议增加计算出的节点数量。

ext2文件系统使用如下命令：

#+BEGIN_SRC
root # mke2fs -T small /dev/<device>
#+END_SRC

ext3和ext4文件系统，增加 =-j= 选项打开日志功能：

#+BEGIN_SRC
root # mke2fs -j -T small /dev/<device>
#+END_SRC

这将生成文件系统索引节点的四倍数量，“多少个字节一个索引节点”，从16KB减小到4KB每个索引节点。可以通过提供一个比例进一步调整：

#+BEGIN_SRC
root # mke2fs -i <ratio> /dev/<device>
#+END_SRC

** 分区使用文件系统

有很多工具可以在分区或卷上创建文件系统：

| Filesystem | Creation Command |
|------------+------------------|
| ext2       | mkfs.ext2        |
| ext3       | mkfs.ext3        |
| ext4       | mkfs.ext4        |
| reiserfs   | mkreiserfs       |
| xfs        | mkfs.xfs         |
| jfs        | mkfs.jfs         |
| vfat       | mkfs.vfat        |

例如，设置启动分区（/dev/sda2）为ext2，主分区（/dev/sda4）为ext4。可以用如下命令：

#+BEGIN_SRC
root # mkfs.ext2 /dev/sda2
root # mkfs.ext4 /dev/sda4
#+END_SRC

现在在新建的分区（或逻辑卷）上创建文件系统。

** 激活交换分区

=mkswap= 是一个初始化交换分区的命令：

#+BEGIN_SRC
root # mkswap /dev/sda3
#+END_SRC

=swapon= 用来激活交换分区：

#+BEGIN_SRC
root #swapon /dev/sda3
#+END_SRC

用上面提到的命令创建并激活交换分区。

* 挂载

现在已经完成分区初始化，并设置了文件系统，现在可以使用 =mount= 挂载这些分区。别忘记建立需要挂载目录。例如我们挂在根分区和启动分区：

#+BEGIN_SRC
root # mount /dev/sda4 /mnt/gentoo
root # mkdir /mnt/gentoo/boot
root # mount /dev/sda2 /mnt/gentoo/boot
#+END_SRC

#+BEGIN_QUOTE
*备注*

如果 ~/tmp/~ 单独分区，在挂载分区后需要修改权限：
=root # chmod 1777 /mnt/gentoo/tmp=
/var/tmp目录也一样。
#+END_QUOTE

接下来会挂载proc文件系统（内核虚拟接口）以及其它伪文件系统，但是首先我们先[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Stage][安装Gentoo文件]]。

* 安装stage包

** 设置日期时间

安装Gentoo前，先确认日期和时间设置正确。错误的时钟设置可能在接下来的安装出现问题。

使用date检查当前日期和时间：

#+BEGIN_SRC
root # date
Fri Mar 29 16:21:18 UTC 2005
#+END_SRC

如果日期和时间显示不正确，用 =MMDDhhmmYYYY= 句法（月日时分年）设置时间。建议使用UTC时间。在接下来的步骤中会设置时区。

例如，设置时间为2014年3月29日16:21：

#+BEGIN_SRC
root # date 032916212014
#+END_SRC

** 下载stage包

进入Gentoo系统文件挂载点（例如/mnt/gentoo）：

#+BEGIN_SRC
root # cd /mnt/gentoo
#+END_SRC

根据安装介质，有很多工具下载stage包。其中之一的 =links= 是一个字符界面菜单式的浏览器。访问Gentoo镜像列表下载stage包：

#+BEGIN_SRC
root # links http://www.gentoo.org/main/en/mirrors.xml
#+END_SRC

可以通过 /-http-proxy/ 选项在 =links= 中使用HTTP代理：

#+BEGIN_SRC
root # links -http-proxy proxy.server.com:8080 http://www.gentoo.org/main/en/mirrors.xml
#+END_SRC

和 =links= 一样的还有 =lynx= 浏览器。它和 =links= 很像，是一个字符型浏览器，但是不是菜单式的。

#+BEGIN_SRC
root # lynx http://www.gentoo.org/main/en/mirrors.xml
#+END_SRC

如果需要设置代理，需要设置 =http_proxy= 和/或 =ftp_proxy= 变量：

#+BEGIN_SRC
root # export http_proxy="http://proxy.server.com:port"
root # export ftp_proxy="http://proxy.server.com:port"
#+END_SRC

在镜像列表中选择一个就近的地址。通常HTTP镜像已足够，但是我们也提供了其它协议。移动到releases/amd64/autobuilds/目录下。这里列出了所有可用的stage文件（可能存储在架构目录下子文件夹中）。选择一个按 =D= 下载。

你最小安装CD一样，有一些附加的文件：

  - A.CONTENTS文件包含stage包里的所有文件的列表
  - A.DIGESTS文件包含stage包多种算法的校验值
  - A.DIGESTS.asc文件像.DIGESTS文件一样也包含stage包多种算法的校验值，同时还包含加密签名以确保是由Gentoo项目提供的stage包。

完成后，按 =Q= 退出。

stage包下载完成后，可能需要验证。使用 =openssl= 和.DIGESTS或者.DIGESTS.asc中的校验值对比。

例如，用SHA512校验：

#+BEGIN_SRC
root # openssl dgst -r -sha512 stage3-amd64-<release>.tar.bz2
#+END_SRC

另一种方法是使用 =sha512sum= 命令：

#+BEGIN_SRC
root # sha512sum stage3-amd64-<release>.tar.bz2
#+END_SRC

验证文件完整性：

#+BEGIN_SRC
root # openssl dgst -r -whirlpool stage3-amd64-<release>.tar.bz2
#+END_SRC

比较.DIGESTS(.asc)文件中的值和命令输出的值，如果两个值不一样，也就是说下载的文件已损坏。

像ISO文件一样，也可以用.DIGESTS.asc文件验证数字签名，使用 =gpg= 命令来确认文件没有被篡改：

#+BEGIN_SRC
root # gpg --verify stage3-amd64-<release>.tar.bz2.DIGESTS.asc
#+END_SRC

** 解压stage包

现在解压stage包到系统上。我们使用 =tar= 命令：

#+BEGIN_SRC
root # tar xvjpf stage3-*.tar.bz2
#+END_SRC

确认使用上面的选项（xvjpf）。x用来取出文件，v用来查看取出文件时的详细信息（可选），j用来解压bzip2格式，p用来保留权限，f表示指定文件不是输入。

现在stage包已经安装完成，继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Configuring_the_compile_options][配置编译选项]]。

* 配置编译选项

** 简介

可以能过设置一些变量影响Portage的行为来优化Gentoo。这些变量可以像设置环境变量一样设置（使用 =export= ），但是这些设置不是永久的。Portage的配置文件是/etc/portage/make.conf，想要一直保存这些设置可以修改这个文件。

#+BEGIN_QUOTE
*备注*

所有可能设置的变量和注释可以在/mnt/gentoo/usr/share/portage/config/make.conf.example文件中找到。成功安装Gentoo只需要设置下面提到的变量。
#+END_QUOTE

接下来我们会讨论怎么启动一个编辑器（在手册中我们用 =nano= ）来修改优化变量。

#+BEGIN_SRC
root # nano -w /mnt/gentoo/etc/portage/make.conf
#+END_SRC

从make.conf.example文件我们可以看到文本的结构：以“#”开头的行为注释行，其它行用VARIABLE="content"的句法定义变量。我们下面会讨论几个变量。

** CFLAGS和CXXFLAGS

CFLAGS和CXXFLAGS变量是gcc的C和C++编译器的优化选项。因为每个程序都是不同的，为了获得最佳性能我们需要为每个程序定义这些变量，这不太方便管理，因此我们将这些标记定义在make.conf文件里。

在make.conf文件中应该定义对系统最效的优化变量，不要在这个文件中定义实验性的变量；太多的优化变量会使程序的行为失常（崩溃，甚至更糟，故障）。

我们不会解释所有的优化选项。如果想查看所有的选项可以阅读[[http://gcc.gnu.org/onlinedocs/][GNU在线手册(s)]]或者gcc帮助信息（ =info gcc= ——只能在可以工作的Linux系统中使用）。make.conf.example文件本身也包含一些示例和信息；不要忘记看一下这里。

首先需要设置 ~-march=~ 或者 ~-mtune=~ 标记，它指定设备架构名称。在make.conf.example文件中可以找到其它选项的说明（注释）。通常会使用 /native/ 来告诉编译器选择当前系统的架构（用户安装Gentoo的架构）。

其次需要设置 =-O= 标记（大写字母O，而不是数字0），它用来指定gcc优化级别。可以是s（大小优化），0（数字0——不优化），1、2或3是速度优化标记（每一个级别都包含前一个级别，并加一些额外优化）。默认推荐 =-O2= ， =-O3= 在系统级使用时会出现问题，所以建议坚持使用 =-O2= 。

另一个常用的优化选项是 =-pipe= （使用管道而不是临时文件来联系各stage编译）。这不影响生成的代码，但是会消耗更多的内存。在小内存的系统上，gcc可能会被迫关闭。这种情况下不要使用这个标记。

使用 =-fomit-frame-pointer= （在不需要的并且已经注册的函数中不保存frame指针）会在调试程序时产生不良后果。

当定义好CFLAGS和CXXFLAGS后，把几个优化参数放在一个字符串中。默认的变量可以很好的为刚刚解压的stage3包工作。下面是一个例子：

#+BEGIN_SRC
CODE Example CFLAGS and CXXFLAGS variables

CFLAGS="-march=native -O2 -pipe"
# Use the same settings for both variables
CXXFLAGS="${CFLAGS}"
#+END_SRC

#+BEGIN_QUOTE
*备注*

[[https://wiki.gentoo.org/wiki/GCC_optimization][GCC优化文档]]有更多的优化选项和对系统作用的信息。
#+END_QUOTE

** MAKEOPTS

=MAKEOPTS= 变量定义了在安装包时的并发编译数。CPUs（或者CPU内核数）的数量加一是个好选择，但是这个建议并不总是会完美运行。

#+BEGIN_SRC
CODE Example MAKEOPTS declaration in make.conf

MAKEOPTS="-j2"
#+END_SRC

** 准备开始

根据个人偏好修改/mnt/gentoo/etc/portage/make.conf文件并保存（nano用户按 =Ctrl+X= ）。

然后继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Base][安装Gentoo基本系统]]。

* 改变根目录

** 选项：选择镜像

#+BEGIN_QUOTE
*警告*

[[http://packages.gentoo.org/package/app-portage/mirrorselect][app-portage/mirrorselect]]尚未更新到修改repos.conf/gentoo.conf文件。同时，在make.conf中的 =SYNC= 已经不再使用。这一章节需要更新，请跳过……
#+END_QUOTE

如果想快速下载源代码，建议使用一个快速的镜像。Portage会在make.conf文件找 =GENTOO_MIRRORS= 变量里的镜像列表。这些列表可以是在Gentoo镜像列表中找一个地理临近的镜像（通常这个比较快）。然而我们提供了一个有用的工具 =mirrorselect= ，它给用户提供了一个选择需要镜像的接口。只需要移动到镜像上按 =Spacebar= 就可以选则一个或几个镜像。

#+BEGIN_SRC
root # mirrorselect -i -o >> /mnt/gentoo/etc/portage/make.conf
#+END_SRC

第二个重要的设置是make.conf中的 =SYNC= 变量。这个变量包含用于同步portage树的服务器（下载和安装软件需要的ebuild和相关的文件信息）。同样，可以手动设置 =SYNC= 变量，也可以使用 =mirrorselect= 如下操作：

#+BEGIN_SRC
root # mirrorselect -i -r -o >> /mnt/gentoo/etc/portage/make.conf
#+END_SRC

当运行完mirrorselect后，建议再检查一下/mnt/gentoo/etc/portage/make.conf文件！

#+BEGIN_QUOTE
*备注*

在make.conf文件中手动修改 =SYNC= 变量时，检查镜像列表是不是离你最近的镜像。建议使用一个轮换链接，像rsync.us.gentoo.org而不是选择单一镜像。当一个镜像离线时，这会帮助分散加载其它镜像。
#+END_QUOTE

** 拷贝DNS信息

在进入新环境前还有一件事要做，就是拷贝/etc/resolv.conf文件中的DNS信息。这可以保证在进入新环境后网络依然可以使用。/etc/resolv.conf包含域名服务器。

建议使用 =cp= 加上 =-L= 选项来拷贝DNS信息。这个可以在/etc/resolv.conf是一个链接的时候，依然可以正确的拷贝原始文件，而不是拷贝链接。另一方面进入新环境后链接也会指向一个不存在的文件（在新环境中链接的目标文件很有可能无效）。

#+BEGIN_SRC
root # cp -L /etc/resolv.conf /mnt/gentoo/etc/
#+END_SRC

** 挂载必要的文件系统

一会儿，Linux的根目录会切换到新的位置。为了确保新环境可以正常工作，最好创建一些必要的文件系统。

  - ~/proc/~ 是一个显示Linux系统内核信息的伪文件系统（它看起来像一个正规文件，但是实际上它是即时生成的）
  - ~/sys/~ 和 ~/proc/~ 很像也是一个文件系统，它曾经是为了替换 ~/proc/~ ，里面的信息也比它更有结构
  - ~/dev/~ 是一个正式的文件系统，Linux设备管理器（经常是udev）可以管理它一部分，它包含了所有的设备文件

~/proc/~ 挂在到 ~/mnt/gentoo/proc/~ 然而另两个是绑定挂载。下面就是例子， ~/mnt/gentoo/sys/~ 会挂载到 ~/sys/~ （同一个文件系统中的第二个进入点）然而 ~/mnt/gentoo/proc~ 是一个新的挂载点（暂时这么说）。

#+BEGIN_SRC
root # mount -t proc proc /mnt/gentoo/proc
root # mount --rbind /sys /mnt/gentoo/sys
root # mount --make-rslave /mnt/gentoo/sys
root # mount --rbind /dev /mnt/gentoo/dev
root # mount --make-rslave /mnt/gentoo/dev
#+END_SRC

#+BEGIN_QUOTE
*备注*

=--make-rslave= 选项是为了支持稍后的systemd。
#+END_QUOTE

#+BEGIN_QUOTE
*警告*

当使用非Gentoo的安装介质，这样做可能还不行。有一些发行片会把/dev/shm链接到 ~/run/shm/~ ，进入新环境后就会失效。将 ~/dev/shm/~ 同时挂载到文件系统上可以修正这个问题：

#+BEGIN_SRC
root # rm /dev/shm && mkdir /dev/shm
root # mount -t tmpfs -o nosuid,nodev,noexec shm /dev/shm
#+END_SRC

确认设置为1777权限

#+BEGIN_SRC
root # chmod 1777 /dev/shm
#+END_SRC
#+END_QUOTE

** 进入新环境

现在所有的分区已经初始化完成并且设置好了基本的环境，是时候进入新的安装环境了。这意味着会话根目录（可以访问的最顶级目录）会从当前安装环境（安装CD或者其它安装介质）切换到安装系统环境（已经初始化的分区），因此得名，改变根目录或者chroot。

改变根目录有三步。

  1. 用chroot改变当前 ~/~ 到 ~/mnt/gentoo/~ （分区）
  2. 用source命令重新加载一些设置到内存
  3. 修改提示符标识这个会话是新改变的环境

#+BEGIN_SRC
root # chroot /mnt/gentoo /bin/bash
root # source /etc/profile
root # export PS1="(chroot) $PS1"
#+END_SRC

从此开始，所有的操作都会在新的Gentoo环境中进行。当然这还远没有完成安装，这也是为什么安装手册还有这么长的原因 :-)

* 配置portage

** 安装portage快照

下一步安装portage快照，快照一个包含所有有效软件安装信息的文件集合，用户可以选择这些软件包。

建议使用 =emerge-webrsync= ，它用来从Gentoo镜像抓取最近的portage快照（Gentoo基本每天都会更新）并安装快照到系统中。

#+BEGIN_SRC
root # emerge-webrsync
#+END_SRC

#+BEGIN_QUOTE
*备注*

这个操作时， =emerge-webrsync= 可能会提示缺少 ~/usr/portage/~ 目录。这不需要担心——这个工具会创建这个目录。
#+END_QUOTE

从正在开始，portage可能提示建议执行一些更新。这是因为stage3包里的一些已经安装的软件包有了新的版本，新的快照安装后portage知道了哪些包需要更新。现在可以忽略这个问题；等Gentoo安装完成后我们可以再更新。

** 选项：更新protage树

可以更新portage树到最新的版本。前面提到的 =emerge-webrsync= 命令会安装最近的portage快照（通常24小时内），所以这一步绝对是可选的。

如果想更新到最后一个包更新（最近1个小时），那么使用 =emerge --sync= 。这个命令会使用rsync协议更新portage树（上面提到的通过 =emerge-webrsync= 抓取的东西）到最近的状态。

#+BEGIN_SRC
root # emerge --sync
#+END_SRC

在较慢的终端中，像一些帧缓冲或者连续的控制台，建议使用 =--quiet= 选项来加快速度：

#+BEGIN_SRC
root # emerge --sync --quiet
#+END_SRC

** 阅读新闻条目

当同步了portage树后，portage可能会出现如下提示：

#+BEGIN_SRC
CODE Portage informing the user about news items

 * IMPORTANT: 2 news items need reading for repository 'gentoo'.
 * Use eselect news to read news items.
#+END_SRC

Portage新闻条目是通过rsync树向用户推送重要信息的媒介。使用 =eselect news= 来管理它们。 =eselect= 是Gentoo用来操作和更改系统的通用管理接口。在这个例子里，我们使用 =eselect= 的 =news= 模块。

=news= 模块有三个常用的操作：

  - =list= 用来显示可用新闻条目的概述
  - =read= 用来读取新闻条目
  - =purge= 如果已经读完了新闻条目并且不想再显示，可以用它来删除新闻条目

#+BEGIN_SRC
root # eselect news list
root # eselect news read
#+END_SRC

用户手册中有更多关于新闻阅读器的信息：

#+BEGIN_SRC
root # man news.eselect
#+END_SRC

** 选择合适的用户配置

用户配置文件是Gentoo系统的基础。它不仅指定默认的 =USE= 、 =CFLAGS= 和其它的重要变量，它还锁定了软件包的版本范围。这都功能都由Gentoo开发者维护。

你可以使用 =eselect= 来查看当前使用的profile，现在使用 =profile= 模块：

#+BEGIN_SRC
root # eselect profile list
Available profile symlink targets:
  [1]   default/linux/amd64/13.0 *
  [2]   default/linux/amd64/13.0/desktop
  [3]   default/linux/amd64/13.0/desktop/gnome
  [4]   default/linux/amd64/13.0/desktop/kde
#+END_SRC

#+BEGIN_QUOTE
*备注*

命令的输出只是一个例子，接下来会有变化。
#+END_QUOTE

可以看到，架构下面还有一些分类用户配置。

查看了amd64架构下的用户配置文件后，用户可以选择自已的配置：

#+BEGIN_SRC
root # eselect profile set 2
#+END_SRC

如果想要一个纯净的64位环境，不要32位应用程序和库，使用non-multilib用户配置：

#+BEGIN_SRC
root # eselect profile list
Available profile symlink targets:
  [1]   default/linux/amd64/13.0 *
  [2]   default/linux/amd64/13.0/desktop
  [3]   default/linux/amd64/13.0/desktop/gnome
  [4]   default/linux/amd64/13.0/desktop/kde
  [5]   default/linux/amd64/13.0/no-multilib
#+END_SRC

下面选择no-multilib用户配置：

#+BEGIN_SRC
root #eselect profile set 5
root #eselect profile list
Available profile symlink targets:
  [1]   default/linux/amd64/13.0
  [2]   default/linux/amd64/13.0/desktop
  [3]   default/linux/amd64/13.0/desktop/gnome
  [4]   default/linux/amd64/13.0/desktop/kde
  [5]   default/linux/amd64/13.0/no-multilib *
#+END_SRC

#+BEGIN_QUOTE
*备注*

developer用户配置文件是为了Gentoo Linux开发，它不是为了普通用户使用。
#+END_QUOTE

** 配置USE变量

=USE= 是一个Gentoo提供给用户非常有用的变量。可以带或不带支持某些特定条目来编译一些程序，例如，一些程序可以用gtk-support或者qt-support来编译。另一些可以用或者不用SSL支持。一些程序甚至可以用帧支持（svgalib）来替代X11支持（X-server）。

一些发行版会携带尽可能多的支持来编译它们的程序，不介意过多的依赖，增加了程序的大小和启动时间。Gentoo用户可以定义编译包时所用的支持。这也是 =USE=　的用处。

用户可以定义在映射在编译选项中的关键字到 =USE= 变量中。例如， =ssl= 可以编译ssl支持到可用的软件中。 =-X= 可以删除X-server支持（注意前面的减号）。 =gnome gtk -kde -qt4= 会支持gnome（和gtk），但不支持kde（qt）支持，完全支持GNOME微调（如果架构支持）。

默认的USE设置放在make.defaults文件中，这个文件是Gentoo的默认用户配置文件。Gentoo使用了一个继承系统（复用）的配置文件，我们不会详细讨论它。最简单的查看当前活动的 =USE= 设置的方法是使用 =emerge --info= ，然后找到USE开头的行：

#+BEGIN_SRC
root # emerge --info | grep ^USE
USE="X acl alsa amd64 berkdb bindist bzip2 cli cracklib crypt cxx dri ..."
#+END_SRC

#+BEGIN_QUOTE
*备注*

上面的例子是缩短的，真正的USE设置列表很长。
#+END_QUOTE

USE标记的完整描述可以在/usr/portage/profiles/use.desc文件中找到。

#+BEGIN_SRC
root # less /usr/portage/profiles/use.desc
#+END_SRC

在 =less= 命令中，可以使用 =↑= 和 =↓= 来滚动屏幕，用 =q= 退出。

例如，我们看一个支持DVD ALSA和CD刻录并基于KDE的USE设置：

#+BEGIN_SRC
root # nano -w /etc/portage/make.conf
#+END_SRC

#+BEGIN_SRC
*文件* /etc/portage/make.conf 基于KDE，支持DVD、ALSA和CD刻录

USE="-gtk -gnome qt4 kde dvd alsa cdr"
#+END_SRC

用户可以在/etc/portage/make.conf文件中增加（或者前面加减号删除USE标记）USE设置，用户可以忽略所有默认的USE设置，完全自已控制，在make.conf文件中以-*开始定义USE：

#+BEGIN_SRC
*文件* /etc/portage/make.conf 忽略默认USE标记

USE="-* X acl alsa ..."
#+END_SRC

* 可选：使用systemd

Gentoo安装手册余下的章节会默认使用OpenRC作为初始化支持系统。如果想使用systemd或者计划使用Gnome3.8或者更高版本（需要systemd支持），请查询[[https://wiki.gentoo.org/wiki/Systemd][systemd]]页面，那里详细的阐述了安装和配置方法。

接下来的Gentoo手册会考虑这种情况。

* 时区

为系统选择时区，在/usr/share/zoneinfo/里查找有效时区，然后写入到/etc/timezone文件中。

#+BEGIN_SRC
root # ls /usr/share/zoneinfo
#+END_SRC

假如选择Europe/Brussels时区：

#+BEGIN_SRC
root # echo "Europe/Brussels" > /etc/timezone
#+END_SRC

请避免使用/usr/sharezoneinfo/Etc/GMT*时区，它们不代表预期的时区。例如GMT-8实际上是GMT+8。

接着，重新配置[[http://packages.gentoo.org/package/sys-libs/timezone-data][sys-libs/timezone-data]]包，它可以根据/etc/timezone为我们更新/etc/localtime文件。/etc/localtime文件用于系统C库识别系统时区。

#+BEGIN_SRC
root # emerge --config sys-libs/timezone-data
#+END_SRC

* 语言设置

大多数用户会想在系统上使用一两个语言。

语言设置不仅是设置系统交互的语言，还设置了字串排序，日期显示等规则。

系统所支持的语言设置在/etc/locale.gen文件中。

#+BEGIN_SRC
root # nano -w /etc/locale.gen
#+END_SRC

下面的语言设置是一个例子，包括了英文（美国）和德文（德国）和字符集格式（如UTF-8）。

#+BEGIN_SRC
文件 /etc/locale.gen 开启美国和德国区域和字符集格式

en_US ISO-8859-1
en_US.UTF-8 UTF-8
de_DE ISO-8859-1
de_DE@euro ISO-8859-15
#+END_SRC

#+BEGIN_QUOTE
*警告*

我们强烈建议最少即用一个UTF-8语言，因为很多应用需要它。
#+END_QUOTE

#+BEGIN_SRC
root # locale-gen
#+END_SRC

使用 =locale -a= 验证语言设置是否有效。

一但完成，就到了设置系统范围的语言设置的时候了。我们再次使用 =eselect= ，不过现在用的是 =locale= 模块。

用 =eselect locale list= 查看有效的设置：

#+BEGIN_SRC
root # eselect locale list
Available targets for the LANG variable:
  [1] C
  [2] POSIX
  [3] en_US
  [4] en_US.iso88591
  [5] en_US.utf8
  [6] de_DE
  [7] de_DE.iso88591
  [8] de_DE.iso885915
  [9] de_DE.utf8
  [ ] (free form)
#+END_SRC

用 =eselect locale set VALUE= 来设置并确认：

#+BEGIN_SRC
root # eselect locale set 9
#+END_SRC

也可以通过/etc/env.d/02locale文件手动完成：

#+BEGIN_SRC
文件 /etc/env.d/02locale 手动设置系统语言环境

LANG="de_DE.UTF-8"
LC_COLLATE="C"
#+END_SRC

请确认已经设置好了语言环境，在稍后构建系统和部署其它软件时，可能的警告或错误提示需要它。

现在重新加载环境：

#+BEGIN_SRC
root # env-update && source /etc/profile
#+END_SRC

我们制作了完整的[[https://wiki.gentoo.org/wiki/Localization/HOWTO][语言指南]]来帮助用户完成这步。另一个有趣的文章是[[https://wiki.gentoo.org/wiki/UTF-8][UTF-8]]指南，里面有在系统中开启UTF-8的具体信息。

* 安装源代码

内核是所有发行版的核心。这是用户程序与系统硬件的中间层。Gentoo给用户提供了好几种内核源码。在[[https://wiki.gentoo.org/wiki/Kernel/Overview][内核概述页面]]有完整描述列表。

基于amd64位的系统，Gentoo推荐[[http://packages.gentoo.org/package/sys-kernel/gentoo-sources][sys-kernel/gentoo-sources]]包。

选择一个合适的内核源码并使用 =emerge= 来安装：

#+BEGIN_SRC
root # emerge --ask sys-kernel/gentoo-sources
#+END_SRC

这会把内核源码安装到 ~/usr/src/~ 目录下，一个叫做linux的链接指向你的内核源代码。

#+BEGIN_SRC
root # ls -l /usr/src/linux
lrwxrwxrwx    1 root   root    12 Oct 13 11:04 /usr/src/linux -> linux-3.16.5-gentoo
#+END_SRC

现在配置并编译内核源代码。有两种方法：

  1. 手动配置并构建内核
  2. 用 =genkernel= 自动构建并安装Linux内核

我们默认用手动配置内核的方法，它是优化系统环境最好的方法。

* 默认：手动配置

** 简介

手动配置内核经常被Linux用户认为是比较困难的一个步骤。其实不然——当配置完几次内核后，将没有人记得它的困难;)

当然，有一件事是真的：了解系统是手动配置内核的前提。在[[http://packages.gentoo.org/package/sys-apps/pciutils][sys-apps/pciutils]]包中的 =lspci= 命令收集了很多信息：

#+BEGIN_SRC
root # emerge --ask sys-apps/pciutils
#+END_SRC

#+BEGIN_QUOTE
*备注*

在切换根目录的情况下，可以忽略pcilib的警告（例如：pcilib: cannot open /sys/bus/pci/devices/）。
#+END_QUOTE

另一个查看系统信息的方法是使用 =lsmod= 命令，它会列出安装CD正在使用的内核模块，这是一个很好的提示。

现在进入内核源代码目录运行 =make menuconfig=。它会启动一个菜单式的配置界面。

#+BEGIN_SRC
root # cd /usr/src/linux
root # make menuconfig
#+END_SRC

配置Linux内核有很多选项。我们先看一些必要项（也就是说，不做这些微调，Gentoo不能正常使用）。在Gentoo wiki里也有一个[[https://wiki.gentoo.org/wiki/Kernel/Gentoo_Kernel_Configuration_Guide][Gentoo内核配置向导]]进一步帮助用户。

** 启动必要选项

确保系统启动所必要的驱动（像SCSI控制器，等）编译到内核，而不是做为一个模块，不这么做的话系统将不会正确启动。

下一步选择正确的处理器类型。我们建议打开MCE选项（如果可以），这样的话在硬件出现问题时会收到通知。在一些架构下（如x86_64），这此错误不会输出到dmesg，而是输出到/dev/mcelog。这需要[[http://packages.gentoo.org/package/app-admin/mcelog][app-admin/mcelog]]包。

同时选择Maintain a devtmpfs file system to mout at /dev，这样启动过程开始前，主要的设备文件已经初始化完成了。

#+BEGIN_SRC
内核 打开devtmpfs支持

Device Drivers --->
  Generic Driver Options --->
    [*] Maintain a devtmpfs filesystem to mount at /dev
    [ ]   Automount devtmpfs at /dev, after the kernel mounted the rootfs
#+END_SRC

现在到File Systems并且选择你使用的文件系统。不要把主要的文件系统编译成模块，这样的话Gentoo不能够挂载分区。同时选择Virtual memory和/proc file system。

#+BEGIN_SRC
内核 选择必要的文件系统

File systems --->
(Select one or more of the following options as needed by your system)
  <*> Second extended fs support
  <*> Ext3 journalling file system support
  <*> The Extended 4 (ext4) filesystem
  <*> Reiserfs support
  <*> JFS filesystem support
  <*> XFS filesystem support
  ...
  Pseudo Filesystems --->
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
#+END_SRC

如果使用PPPoE连接因特网，或者使用调制解调器拨号，那么要打开如下选项：

#+BEGIN_SRC
内核 选择PPPoE必须的驱动

Device Drivers --->
  Network device support --->
    <*> PPP (point-to-point protocol) support
    <*>   PPP support for async serial ports
    <*>   PPP support for sync tty ports
#+END_SRC

两个压缩选项没什么害处，但也不是必要的，PPP over Ethernet选择也是这样，可能只有当PPPoE配置为内核模式时被ppp使用到。

不要忘记在内核里选择网卡（以太网或者无线）。

有很多系统的处理器是多核的，所以选择Symmetric multi-processing support也很重要：

#+BEGIN_SRC
内核 打开SMP支持

Processor type and features  --->
  [*] Symmetric multi-processing support
#+END_SRC

#+BEGIN_QUOTE
*备注*

在多核系统中，每个核算一个处理器。
#+END_QUOTE

如果使用USB输入设备（如键盘或鼠标），别忘记打开这些选项：

#+BEGIN_SRC
内核 打开输入设备USB支持

Device Drivers --->
  [*] HID Devices  --->
    <*>   USB Human Interface Device (full HID) support
#+END_SRC

** 如构相关配置

如果想运行32位的程序，需要确认打开了IA32 Emulation（multilib）。系统会默认安装multilib系统（32位/64位计算），所以除了使用no-multiblib用户配置文件，都需要这个选项。

#+BEGIN_SRC
内核 选择处理器类形和选项

Processor type and features  --->
   [ ] Machine Check / overheating reporting
   [ ]   Intel MCE Features
   [ ]   AMD MCE Features
  Processor family (AMD-Opteron/Athlon64)  --->
    ( ) Opteron/Athlon64/Hammer/K8
    ( ) Intel P4 / older Netburst based Xeon
    ( ) Core 2/newer Xeon
    ( ) Intel Atom
    ( ) Generic-x86-64
Executable file formats / Emulations  --->
   [*] IA32 Emulation
#+END_SRC

如果像前面提到的那样磁盘分区的话，需要打开GPT分区表支持：

#+BEGIN_SRC
内核 打开GPT支持

-*- Enable the block layer --->
    ...
    Partition Types --->
    [*] Advanced partition selection
      ...
      [*] EFI GUID Partition support
#+END_SRC

如果使用UEFI来启动系统，打开EFI stub support和EFI variables：

#+BEGIN_SRC
KERNEL Enable support for UEFI

Processor type and features  --->
    [*] EFI runtime service support
    [*]   EFI stub support

Firmware Drivers  --->
    <*> EFI Variable Support via sysfs
#+END_SRC

** 编译安装

配置完成，现在开始编译并安装内核。退出配置界面，开始编译：

#+BEGIN_SRC
root # make && make modules_install
#+END_SRC

#+BEGIN_QUOTE
*备注*

如果想并发构建系统，使用 =make -jX= ,X是并发任务数。这和前面手册里提到的，/etc/portage/make.conf文件中的 =MAKEOPTS= 变量一样。
#+END_QUOTE

当内核编译完成后，拷贝镜像到 ~/boot/~ 目录下。这可以使用 =make install= 命令完成：

#+BEGIN_SRC
root # make install
#+END_SRC

这会把内核镜像，System.map文件和内核配置文件拷贝到 ~/boot/~ 目录下。

在UEFI系统上，创建/boot/efi/boot/目录，拷贝内核到这个目录下，并改名为bootx64.efi：

#+BEGIN_SRC
root # mkdir -p /boot/efi/boot
root # cp /boot/vmlinuz /boot/efi/boot/bootx64.efi
#+END_SRC

** 选项：构建initramfs

特殊的情况下需要构建一个initramfs——一个基于内存的文件系统。大多数的原因是重要的系统目录（像 ~/usr/~ 或 ~/var/~ ）在不同的分区。有了initramfs，可以用initramfs里的工具正常挂载这些分区。

如果没有initramfs，系统可能会存在一个巨大的风险，因为不能挂载文件系统，导致系统不能读取需要的信息，从而不能正确启动。initramfs可以把必要的文件先存档，这个存档会在内核启动后和把控制权交到初始化工具前使用。initramfs里的脚本会确保在系统继续启动前正确挂载分区。

要安装initramfs，先安装[[http://packages.gentoo.org/package/sys-kernel/genkernel][sys-kernel/genkernel]]，然后生成一个initramfs：

#+BEGIN_SRC
root # emerge genkernel
root # genkernel --install initramfs
#+END_SRC

要想在initramfs里安装指定支持，像lvm或者raid，要增加对应的选项到genkernel。用 =genkernel --help= 查看更多信息。下面的例子打开LVM和raid（mdadm）：

#+BEGIN_SRC
root # genkernel --lvm --mdadm --install initramfs
#+END_SRC

initramfs会保存在 ~/boot/~ 中。可以查看initramfs开头的文件看到结果：

#+BEGIN_SRC
root # ls /boot/initramfs*
#+END_SRC

继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation#Kernel_modules][Kernel modules]]。

* 可选：使用genkernel

如果手动配置令你望而却步，建议使用 =genkernel= 。它会自动配置和构建内核。

=genkernel= 使用安装CD内核的配置来配置一个内核。这就意味着使用 =genkernel= 来构建内核，在启动时系统一般会检测所有的硬件设备，就像安装CD一样。因为 =genkernel= 不需要任何手动配置，这对于不想编译自已的内核的用户是个好主意。

现在，我们来看怎么使用genkernel。首先，emerge [[http://packages.gentoo.org/package/sys-kernel/genkernel][sys-kernel/genkernel]]安装程序。

#+BEGIN_SRC
root # emerge --ask sys-kernel/genkernel
#+END_SRC

下一步，编辑/etc/fstab文件，以便包含 ~/boot/~ 的第二个字段，作为第一个字段并指向正确的设备。如果按照手册的例子操作，这个设备可能是ext2文件系统的/dev/sd2设备。文件的条目看起来像这样：

#+BEGIN_SRC
root # nano -w /etc/fstab
#+END_SRC

#+BEGIN_SRC
文件 /etc/fstab 配置启动分区挂载点

/dev/sda2	/boot	ext2	defaults	0 2
#+BEGIN_SRC

#+BEGIN_QUOTE
*备注*

下面的Gentoo安装指导, 会再次配置/etc/fstab文件。 =genkernel= 现在需要这样的启动分区设置，它会读取这个文件。
#+END_QUOTE

现在，执行 =genkernel all= 编译内核源代码。请注意，这样编译的内核支持几乎所有的硬件设备，编译会消耗很长时间！

#+BEGIN_QUOTE
*备注*

如果启动分区不是使用的ext2或者ext3文件系统，可能需要用 =genkernel --menuconfig all= 来手动配置内核的文件系统。LVM2的用户需要增加 =--lvm= 参数。

#+BEGIN_SRC
root # genkernel all
#+END_SRC

如果完成了内核编译，一个拥有完整模块和初始化内存磁盘（initramfs）就已创建完成。我们会在接下来配置启动引导器，会使用内核和initrd。配置启动引导器文件时，把内核和initrd的名字写在这个配置中。启动硬件检查（像安装CD那样）之后，initrd会立即启动，然后才会进入“正式的”系统。

#+BEGIN_SRC
root # ls /boot/kernel* /boot/initramfs*
#+END_SRC

* 内核模块

** 配置模块

将需要自动加载的模块写入到/etc/conf.d/modules。如果需要也可以增加其它的模块。

使用如下的 =find= 命令查看所有有效的模块。将刚刚编译的内核版本替换“<kernel version>”：

#+BEGIN_SRC
root # find /lib/modules/<kernel version>/ -type f -iname '*.o' -or -iname '*.ko' | less
#+END_SRC

例如，自动加载3c59x.ko模块（3Com系列网卡的驱动），编辑/etc/conf.d/modules文件并输入模块名。

#+BEGIN_SRC
root # nano -w /etc/conf.d/modules
modules="3c59x"
#+END_SRC

继续阅读[[https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/System][配置系统]]。

** 选项：安装固件

一些驱动工作前，需要安装附加的固件。网络接口经常需要这么做，特别是无线网络接口，多数的固件已经打包为[[http://packages.gentoo.org/package/sys-kernel/linux-firmware][sys-kernel/linux-firmware]]：

#+BEGIN_SRC
root # emerge --ask sys-kernel/linux-firmware
#+END_SRC

* 文件系统信息

** fstab

在Linux系统中，系统使用的所有分区必须写在/etc/fstab文件中。这个文件包含了这些分区的挂载点（看起来像文件系统结构），带什么选项怎么挂载（自动或者手动，用户是否可以挂载，等）。

** 创建fstab文件

/etc/fstab文件使用一种表格式的语法。每行有六个字段，由空白符（空格符，制表符或者两者混合）。每一个字段有它的意义：

  1. 第一个字段表示分区描述（设备文件路径）
  2. 第二个字段表示分区的挂载点
  3. 第三个字段表示分区的文件系统类型
  4. 第四个字段表示挂载分区时所需的选项。每一个文件系统都有其自己的挂载选项，建议用户阅读 =mount= 的帮助页面（ =man mount= ）要看完整选项，多个选项由逗号分隔
  5. 第五个字段用于dump，判断分区是否需要废弃，一般情况下设置为0（零）
  6. 第六个字段用于fsck，判断当系统未正常关闭时检查的顺序，根目录需要设置为1，其它的设置为2（如果不需要检查的话设置为0）

#+BEGIN_QUOTE
*重要*

Gentoo提供的默认/etc/fstab不是有效的fstab文件，只是一个模板。
#+END_QUOTE

#+BEGIN_SRC
root # nano -w /etc/fstab
#+END_SRC

在下面的章节中，我们使用默认的/dev/sd*块文件做为分区。用户可以选择使用/dev/disk/by-id或者/dev/disk/by-uuid/目录中的链接。这些名字不能修改，然而默认的块设备文件名依赖于许多因素（像磁盘怎么连接到系统）。然而很少有人会乱动磁盘顺序，你可以继续安全使用块设备文件。

让我们看看怎么设置 ~/boot/~ 分区选项。这只是一个例子，请根据前面的安装设定来修改。在我们amd64架构分区例子中， ~/boot/~ 一般是/dev/sda2分区和ext2文件系统。系统启动时会进行检查，我以我们这样写：

#+BEGIN_SRC
文件 /etc/fstab 一个/boot的例子

/dev/sda2   /boot     ext2    defaults        0 2
#+END_SRC

一些用户不想自动挂载 ~/boot/~ 分区增加系统安装。这些人需要修改default为noauto。这意味着这些用户每次用到这个分区时需要手动挂载。


像前文件的分区方案设置规则，并增加CD-ROM驱动器，如果还有其它的分区，也这么设置。

下面是一个/etc/fstab文件的详细例子：

#+BEGIN_SRC
文件 /etc/fstab 一个完整的例子

/dev/sda2   /boot        ext2    defaults,noatime     0 2
/dev/sda3   none         swap    sw                   0 0
/dev/sda4   /            ext4    noatime              0 1

/dev/cdrom  /mnt/cdrom   auto    noauto,user          0 0
#+END_SRC

第第三个字段用auto关键字，它让挂载命令自己猜测是什么文件系统。建议移动存储器使用这个关键字，因为它们可能被建立为许多不同的文件系统。第四个字段让不是超级用户的账户挂载CD。

为了提升性能，大多数用户需要noatime挂载选项，从而导致更快的系统，因为没有注册访问时间（一般来说我们不需要）。这也有一些给固态硬盘（SSD）用户的建议，你应用打开discard选项（现在只有ext4和btrfs需要），它可以供 =TRIM= 命令工作。

重新检查/etc/fstab文件，保存退出并继续安装。




----------------------------
译注：
partition table : 分区列表
partition layout : 分区表
reader : 用户
alternative : 可选
optional : 选项
note : 备注
media : 介质
profile : 用户配置
locales : 区域
